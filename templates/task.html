{% extends 'app.html' %}

{% block title %}Tasks{% endblock %}

{% block css %}
{{ super() }}
<style>
    .tag-chip,
    .tag-pill {
        border-radius: 999px;
        padding: 0.25rem 0.75rem;
        font-size: var(--bs-body-font-size, 1rem);
        font-weight: 500;
        display: inline-flex;
        align-items: center;
        gap: 0.25rem;
        border: var(--bs-border-width, 1px) solid var(--bs-border-color);
        border-width: calc(var(--bs-border-width, 1px) * 1.5);
        transition: all 0.15s ease-in-out;
    }

    .tag-chip {
        cursor: pointer;
        background-color: transparent;
        color: var(--bs-body-color);
    }

    .tag-chip:hover {
        background-color: var(--bs-tertiary-bg);
    }

    .tag-chip.active,
    .tag-chip.assigned {
        background-color: var(--bs-primary);
        border-color: var(--bs-primary);
        color: var(--bs-white);
    }

    .tag-chip.assigned:not(.active) {
        background-color: var(--bs-secondary);
        border-color: var(--bs-secondary);
    }

    .tag-pill {
        background-color: var(--bs-tertiary-bg);
        color: var(--bs-secondary-color, var(--bs-secondary));
    }

    .tag-section-label {
        font-size: 0.8rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: var(--bs-secondary-color, var(--bs-secondary));
    }

    .tag-filter-toolbar {
        background-color: var(--bs-body-bg);
        border-radius: 0.75rem;
        border: 1px solid var(--bs-border-color);
        padding: 0.75rem 1rem;
    }

    .drag-disabled {
        opacity: 0.35;
        cursor: default !important;
        pointer-events: none;
    }

    .btn-pastel-success,
    .btn-pastel-danger {
        border-width: 1px;
        border-style: solid;
        transition: all 0.15s ease-in-out;
        color: var(--bs-body-color);
        border-color: var(--bs-secondary-border-subtle, #ced4da);
        background-color: var(--bs-tertiary-bg);
    }

    .btn-pastel-success:hover,
    .btn-pastel-success:focus,
    .btn-pastel-danger:hover,
    .btn-pastel-danger:focus {
        color: var(--bs-body-color);
        border-color: var(--bs-secondary-color, #adb5bd);
        background-color: var(--bs-secondary-bg, #e9ecef);
    }

    .task-chevron {
        transition: transform 0.2s ease-in-out;
    }

    .task-chevron-rotated {
        transform: rotate(90deg);
    }

    .task-description {
        white-space: pre-wrap;
    }

    .inline-tag-input-group .form-control {
        min-height: 2.5rem;
    }

    #tag-filter-clear {
        border: none;
        background: transparent;
        color: var(--bs-secondary-color, var(--bs-secondary));
        display: inline-flex;
        align-items: center;
        padding: 0;
    }

    #tag-filter-clear:hover,
    #tag-filter-clear:focus {
        color: var(--bs-body-color);
    }

    .task-meta {
        font-size: 0.8rem;
        color: var(--bs-secondary-color, var(--bs-secondary));
    }

    .task-tags:empty {
        display: none;
    }

    .inline-tag-chip {
        border-radius: 999px;
        padding: 0.25rem 0.75rem;
        border: var(--bs-border-width, 1px) solid var(--bs-border-color);
        border-width: calc(var(--bs-border-width, 1px) * 1.5);
        font-size: var(--bs-body-font-size, 1rem);
        font-weight: 500;
        background-color: var(--bs-body-bg);
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        gap: 0.25rem;
    }

    .inline-tag-chip.active {
        background-color: var(--bs-primary);
        color: var(--bs-white);
        border-color: var(--bs-primary);
    }

    .tag-filter-button {
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
    }

    .tag-filter-label {
        display: inline-flex;
        align-items: center;
    }

    .tag-filter-remove {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 1.25rem;
        height: 1.25rem;
        border-radius: 999px;
        cursor: pointer;
        color: inherit;
    }

    .tag-filter-remove:hover,
    .tag-filter-remove:focus {
        background-color: rgba(0, 0, 0, 0.08);
    }

    .tag-filter-button .tag-filter-remove i {
        pointer-events: none;
    }

    .task-action-btn {
        border: var(--bs-border-width, 1px) solid var(--bs-border-color);
        background-color: var(--bs-tertiary-bg);
        color: var(--bs-body-color);
        transition: all 0.15s ease-in-out;
    }

    .task-action-btn:hover,
    .task-action-btn:focus {
        background-color: var(--bs-secondary-bg, #e9ecef);
        border-color: var(--bs-secondary-border-subtle, #ced4da);
        color: var(--bs-body-color);
    }
</style>
{% endblock %}

{% block content %}

<div class="container">
    <div class="tag-filter-toolbar d-flex flex-column gap-3">
        <form action="{{ url_for('task') }}" method="get" class="row g-3 align-items-end" id="task-filter-form">
            <div class="col-12 col-md-4">
                <label for="search" class="form-label">Search tasks</label>
                <input type="search" class="form-control form-control-sm" id="search" name="search" value="{{ search_query }}" placeholder="Search by name or description" autocomplete="off">
            </div>
            <div class="col-12 col-md-3">
                <label for="sort_by" class="form-label">Sort by</label>
                <select class="form-select form-select-sm" id="sort_by" name="sort_by">
                    <option value="rank" {{ 'selected' if sort_by == 'rank' else '' }}>Rank</option>
                    <option value="name" {{ 'selected' if sort_by == 'name' else '' }}>Name</option>
                    <option value="tags" {{ 'selected' if sort_by == 'tags' else '' }}>Tags</option>
                    <option value="due_date" {{ 'selected' if sort_by == 'due_date' else '' }}>Due date</option>
                </select>
            </div>
            <div class="col-12 col-md-3">
                <div class="form-check form-switch mt-md-4 pt-1">
                    <input class="form-check-input" type="checkbox" role="switch" id="filter-completed" name="show_completed" value="true" {{ 'checked' if show_completed else '' }}>
                    <label class="form-check-label" for="filter-completed">Show completed tasks</label>
                </div>
            </div>
        </form>
        <div class="d-flex flex-column flex-lg-row gap-2 align-items-lg-center">
            <div class="d-flex align-items-center gap-2">
                <span class="tag-section-label mb-0">Tags:</span>
                <button type="button" class="btn btn-sm" id="tag-filter-clear" aria-label="Clear tag filters">
                    <i class="bi bi-x-circle"></i>
                </button>
            </div>
            <div class="d-flex flex-wrap gap-2" id="tag-filter-container">
                {% for tag in available_tags %}
                    <button type="button" class="btn btn-sm tag-chip tag-filter-button" data-tag-id="{{ tag.id }}" data-tag-name="{{ tag.name | e }}" data-tag-count="{{ tag_usage.get(tag.id, 0) }}">
                        <span class="tag-filter-label">#{{ tag.name }}</span>
                        <span class="tag-filter-remove" role="button" tabindex="0" aria-label="Delete tag #{{ tag.name }}" data-tag-id="{{ tag.id }}">
                            <i class="bi bi-x-lg"></i>
                        </span>
                    </button>
                {% endfor %}
            </div>
            <p class="text-muted mb-0 small {% if available_tags %}d-none{% endif %}" id="tag-filter-empty">
                No tags yet. Add tags to tasks to start filtering.
            </p>
        </div>
    </div>
</div>

<div class="container mt-2">
    <form id="task-form" method="post" action="{{ url_for('add_task') }}">
        {{ task_form.hidden_tag() }}
        {{ task_form.tags() }}
        <div  class="accordion" id="quick-item-accordion">
            <div class="input-group mb-3">
                <span class="input-group-text clickable-icon collapsed" data-bs-toggle="collapse" data-bs-target="#detailed-item-container">
                    <i class="bi bi-chevron-down text-muted"></i>
                </span>
                {{ task_form.name(class_='form-control'+ (' is-invalid' if task_form.name.errors else ''), placeholder_="Add new task...") }}
                <button id="quick-add-btn" class="btn btn-primary" type="submit">
                    <i class="bi bi-floppy"></i>
                </button>
                <button id="quick-cancel-btn" class="btn btn-secondary" type="reset">
                    <i class="bi bi-x-circle"></i>
                </button>
                {% if task_form.name.errors %}
                    {% for error in task_form.name.errors %}
                        <div class="invalid-feedback" style="display:block;">{{ error }}</div>
                    {% endfor %}
                {% endif %}
            </div>
        </div>
        <div id="detailed-item-container" class="accordion-collapse collapse" data-bs-parent="#quick-item-accordion">
            <div class="accordion-body">
                <div class="form-floating mb-3">
                    {{ task_form.description(class_='form-control auto-resize-textarea', rows=3, placeholder_='Add more details') }}
                    {{ task_form.description.label(class_='form-label') }}
                    {% if task_form.description.errors %}
                        {% for error in task_form.description.errors %}
                            <div class="invalid-feedback" style="display:block;">{{ error }}</div>
                        {% endfor %}
                    {% endif %}
                </div>
                <div class="form-floating mb-3">
                    {{ task_form.end_date(class_='form-control') }}
                    {{ task_form.end_date.label(class_='form-label') }}
                    {% if task_form.end_date.errors %}
                        {% for error in task_form.end_date.errors %}
                            <div class="invalid-feedback" style="display:block;">{{ error }}</div>
                        {% endfor %}
                    {% endif %}
                </div>
                <div class="mb-3">
                    <div class="d-flex flex-wrap gap-2" id="task-inline-tag-options"></div>
                    <p class="text-muted small mb-2 d-none" id="task-inline-tag-empty">No tags yet. Create one below.</p>
                    <div class="input-group input-group-sm inline-tag-input-group mt-3">
                        <span class="input-group-text">#</span>
                        <input type="text" class="form-control" id="task-inline-tag-input" placeholder="Add a tag and press Enter">
                        <button class="btn btn-outline-primary" type="button" id="task-inline-tag-add">Add</button>
                    </div>
                    <div class="invalid-feedback d-none" id="task-inline-tag-feedback">Please enter a tag name.</div>
                </div>
            </div>
        </div>
    </form>
</div>

{% include 'components/task_groups.html' %}
{% endblock %}

{% block modals %}
    {{ super() }}
    <div class="modal fade" id="tagManagerModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Manage tags</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <p class="text-muted small mb-2" id="tag-modal-task-name"></p>
                    <div class="mb-3">
                        <div class="d-flex flex-wrap gap-2" id="tag-modal-available"></div>
                        <p class="text-muted small mb-0 d-none" id="tag-modal-empty">No tags yet. Create one below.</p>
                    </div>
                    <div class="input-group">
                        <span class="input-group-text">#</span>
                        <input type="text" class="form-control" id="new-tag-input" placeholder="Create a new tag">
                        <button class="btn btn-outline-primary" id="create-tag-btn" type="button">Add</button>
                    </div>
                    <div class="invalid-feedback d-none" id="new-tag-feedback">Please enter a tag name.</div>
                </div>
            </div>
        </div>
    </div>
{% endblock modals %}

{% block scripts %}
{{ super() }}
<script>
    function debounce(fn, delay = 300) {
        let timeoutId;
        return (...args) => {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(() => fn.apply(null, args), delay);
        };
    }

    function getTaskGroupsContainer() {
        return document.getElementById('task-groups-container');
    }

    function initializeSortableGroups() {
        const container = getTaskGroupsContainer();
        if (!container) {
            return;
        }
        let sortableGroupIds = [];
        try {
            sortableGroupIds = JSON.parse(container.dataset.sortableGroups || '[]');
        } catch (error) {
            sortableGroupIds = [];
        }
        if (Array.isArray(sortableGroupIds)) {
            sortableGroupIds.forEach((groupId) => {
                initializeSortable(groupId, 'task');
            });
        }
    }

    function getCurrentSortBy() {
        const container = getTaskGroupsContainer();
        return container ? container.dataset.sortBy || null : null;
    }

    function updateChevronForCollapse(collapseId, isExpanded) {
        if (!collapseId) {
            return;
        }
        const icon = document.querySelector(`.task-chevron[data-chevron-for="${collapseId}"]`);
        if (icon) {
            icon.classList.toggle('task-chevron-rotated', isExpanded);
        }
    }

    function syncChevronStates() {
        document.querySelectorAll('.task-chevron').forEach((icon) => {
            const collapseId = icon.dataset.chevronFor;
            if (!collapseId) {
                return;
            }
            const target = document.getElementById(collapseId);
            if (!target) {
                return;
            }
            icon.classList.toggle('task-chevron-rotated', target.classList.contains('show'));
        });
    }

    document.addEventListener('show.bs.collapse', (event) => {
        updateChevronForCollapse(event.target.id, true);
    });

    document.addEventListener('hide.bs.collapse', (event) => {
        updateChevronForCollapse(event.target.id, false);
    });

    const taskForm = document.getElementById('task-form');
    const quickCancelBtn = document.getElementById('quick-cancel-btn');
    const nameField = document.getElementById('name');
    const descriptionField = document.getElementById('description');
    const endDateField = document.getElementById('end_date');
    const tagsField = document.getElementById('tags');
    const inlineTagOptions = document.getElementById('task-inline-tag-options');
    const inlineTagEmpty = document.getElementById('task-inline-tag-empty');
    const inlineTagInput = document.getElementById('task-inline-tag-input');
    const inlineTagAddBtn = document.getElementById('task-inline-tag-add');
    const inlineTagFeedback = document.getElementById('task-inline-tag-feedback');

    const filterForm = document.getElementById('task-filter-form');
    const searchInput = document.getElementById('search');
    const sortSelect = document.getElementById('sort_by');
    const filterCompleted = document.getElementById('filter-completed');
    const filterContainer = document.getElementById('tag-filter-container');
    const filterClear = document.getElementById('tag-filter-clear');
    const filterEmptyMessage = document.getElementById('tag-filter-empty');

    const detailedItemContainer = document.getElementById('detailed-item-container');
    const quickToggleIcon = document.querySelector('[data-bs-target="#detailed-item-container"] i');

    if (detailedItemContainer && quickToggleIcon) {
        const setQuickToggleIcon = (isExpanded) => {
            quickToggleIcon.classList.toggle('bi-chevron-down', !isExpanded);
            quickToggleIcon.classList.toggle('bi-chevron-up', isExpanded);
        };
        setQuickToggleIcon(detailedItemContainer.classList.contains('show'));
        detailedItemContainer.addEventListener('show.bs.collapse', () => setQuickToggleIcon(true));
        detailedItemContainer.addEventListener('hide.bs.collapse', () => setQuickToggleIcon(false));
    }

    function convertToLocal(utcDateString) {
        if (!utcDateString) {
            return '';
        }
        const normalized = utcDateString.endsWith('Z') ? utcDateString : `${utcDateString}Z`;
        const date = new Date(normalized);
        if (Number.isNaN(date.getTime())) {
            return '';
        }

        const pad = (number) => (number < 10 ? `0${number}` : number);
        const yyyy = date.getFullYear();
        const MM = pad(date.getMonth() + 1);
        const dd = pad(date.getDate());
        const hh = pad(date.getHours());
        const mm = pad(date.getMinutes());

        return `${yyyy}-${MM}-${dd}T${hh}:${mm}`;
    }

    function formatDateTimeDisplay(utcDateString) {
        if (!utcDateString) {
            return '';
        }
        const normalized = utcDateString.endsWith('Z') ? utcDateString : `${utcDateString}Z`;
        const date = new Date(normalized);
        if (Number.isNaN(date.getTime())) {
            return '';
        }
        return date.toLocaleString(undefined, {
            year: 'numeric',
            month: 'short',
            day: 'numeric',
            hour: 'numeric',
            minute: 'numeric',
        });
    }

    function autoResizeTextarea(textarea) {
        if (!textarea) {
            return;
        }
        textarea.style.height = 'auto';
        textarea.style.height = `${textarea.scrollHeight}px`;
    }

    function syncInlineTagsField() {
        if (!tagsField) {
            return;
        }
        tagsField.value = Array.from(inlineSelectedTags.keys()).join(',');
    }

    function collectTagInfoForTask(taskId) {
        const info = new Map();
        if (!taskId) {
            return info;
        }
        const container = document.getElementById(`task-tags-${taskId}`);
        if (!container) {
            return info;
        }
        container.querySelectorAll('[data-tag-id]').forEach((pill) => {
            const id = String(pill.dataset.tagId);
            info.set(id, {
                id: Number(id),
                name: pill.dataset.tagName || pill.textContent.replace('#', '').trim(),
            });
        });
        return info;
    }

    function setInlineTagsFromString(tagString, taskId = null) {
        inlineSelectedTags = new Map();
        if (!tagString) {
            syncInlineTagsField();
            renderInlineTagOptions();
            if (inlineTagFeedback) {
                inlineTagFeedback.classList.add('d-none');
            }
            return;
        }
        const tagInfo = collectTagInfoForTask(taskId);
        tagString.split(',').forEach((value) => {
            const trimmed = value.trim();
            if (!trimmed) {
                return;
            }
            let tag = availableTagsMap.get(trimmed);
            if (!tag) {
                tag = tagInfo.get(trimmed);
            }
            if (!tag) {
                tag = { id: Number(trimmed), name: trimmed };
            }
            inlineSelectedTags.set(String(tag.id), {
                id: Number(tag.id),
                name: tag.name || trimmed,
            });
            ensureTagInFilter(tag);
        });
        syncInlineTagsField();
        renderInlineTagOptions();
        if (inlineTagFeedback) {
            inlineTagFeedback.classList.add('d-none');
        }
    }

    function renderInlineTagOptions() {
        if (!inlineTagOptions) {
            return;
        }
        inlineTagOptions.innerHTML = '';
        const tags = Array.from(availableTagsMap.values()).sort((a, b) => a.name.localeCompare(b.name));
        if (tags.length === 0) {
            if (inlineTagEmpty) {
                inlineTagEmpty.classList.remove('d-none');
            }
            return;
        }
        if (inlineTagEmpty) {
            inlineTagEmpty.classList.add('d-none');
        }
        tags.forEach((tag) => {
            const chip = document.createElement('button');
            chip.type = 'button';
            chip.className = 'inline-tag-chip';
            chip.dataset.tagId = String(tag.id);
            chip.textContent = `#${tag.name}`;
            if (inlineSelectedTags.has(String(tag.id))) {
                chip.classList.add('active');
            }
            chip.addEventListener('click', handleInlineTagToggle);
            inlineTagOptions.appendChild(chip);
        });
    }

    function handleInlineTagToggle(event) {
        event.preventDefault();
        const tagId = event.currentTarget.dataset.tagId;
        if (!tagId) {
            return;
        }
        const tag = availableTagsMap.get(tagId);
        if (!tag) {
            return;
        }
        if (inlineSelectedTags.has(tagId)) {
            inlineSelectedTags.delete(tagId);
        } else {
            inlineSelectedTags.set(tagId, tag);
        }
        syncInlineTagsField();
        renderInlineTagOptions();
        if (inlineTagFeedback) {
            inlineTagFeedback.classList.add('d-none');
        }
    }

    function clearInlineSelection() {
        inlineSelectedTags = new Map();
        syncInlineTagsField();
        renderInlineTagOptions();
        if (inlineTagInput) {
            inlineTagInput.value = '';
        }
        if (inlineTagFeedback) {
            inlineTagFeedback.classList.add('d-none');
        }
    }

    function createTagOnServer(rawValue) {
        const normalized = (rawValue || '').replace(/^#+/, '').trim();
        if (!normalized) {
            return Promise.reject({ error: 'Please enter a tag name.' });
        }
        if (!csrfToken) {
            return Promise.reject({ error: 'Missing CSRF token.' });
        }
        return fetch('/tags', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrfToken,
            },
            body: JSON.stringify({ name: normalized }),
        })
            .then((response) => {
                if (!response.ok) {
                    return response.json().then((data) => Promise.reject(data));
                }
                return response.json();
            })
            .then((data) => {
                if (!data || !data.tag) {
                    return Promise.reject({ error: 'Unable to create tag.' });
                }
                return data.tag;
            });
    }

    function handleInlineTagCreate() {
        if (!inlineTagInput) {
            return;
        }
        createTagOnServer(inlineTagInput.value)
            .then((tag) => {
                ensureTagInFilter(tag);
                inlineSelectedTags.set(String(tag.id), {
                    id: Number(tag.id),
                    name: tag.name,
                });
                syncInlineTagsField();
                renderInlineTagOptions();
                inlineTagInput.value = '';
                if (inlineTagFeedback) {
                    inlineTagFeedback.classList.add('d-none');
                }
            })
            .catch((error) => {
                if (inlineTagFeedback) {
                    const message = error && error.error ? error.error : 'Unable to create tag.';
                    inlineTagFeedback.textContent = message;
                    inlineTagFeedback.classList.remove('d-none');
                }
            });
    }

    function updateDateDisplays() {
        document.querySelectorAll('.due-date').forEach((element) => {
            const formatted = formatDateTimeDisplay(element.dataset.utcDate);
            if (formatted) {
                element.textContent = `Due: ${formatted}`;
            }
        });
        document.querySelectorAll('.completed-date').forEach((element) => {
            const formatted = formatDateTimeDisplay(element.dataset.completedDate);
            if (formatted) {
                element.textContent = `Completed: ${formatted}`;
            }
        });
    }

    const csrfTokenInput = taskForm ? taskForm.querySelector('input[name="csrf_token"]') : null;
    const csrfToken = csrfTokenInput ? csrfTokenInput.value : null;

    const tagModalElement = document.getElementById('tagManagerModal');
    const tagModal = tagModalElement ? new bootstrap.Modal(tagModalElement) : null;
    const tagModalAvailable = document.getElementById('tag-modal-available');
    const tagModalEmpty = document.getElementById('tag-modal-empty');
    const tagModalTaskName = document.getElementById('tag-modal-task-name');
    const newTagInput = document.getElementById('new-tag-input');
    const newTagFeedback = document.getElementById('new-tag-feedback');
    const createTagBtn = document.getElementById('create-tag-btn');

    let availableTagsMap = new Map();
    let currentTaskId = null;
    let currentTaskTags = new Map();
    let inlineSelectedTags = new Map();

    function updateFilterEmptyState() {
        if (!filterContainer || !filterEmptyMessage) {
            return;
        }
        const hasTags = filterContainer.querySelectorAll('.tag-filter-button').length > 0;
        filterEmptyMessage.classList.toggle('d-none', hasTags);
    }

    function hydrateAvailableTagsFromFilter() {
        if (!filterContainer) {
            return;
        }
        availableTagsMap = new Map();
        filterContainer.querySelectorAll('.tag-filter-button').forEach((button) => {
            const tagId = String(button.dataset.tagId);
            availableTagsMap.set(tagId, {
                id: Number(tagId),
                name: button.dataset.tagName || button.textContent.replace('#', '').trim(),
                task_count: Number(button.dataset.tagCount || '0'),
            });
        });
        updateFilterEmptyState();
    }

    function createFilterButton(tag) {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'btn btn-sm tag-chip tag-filter-button';
        button.dataset.tagId = String(tag.id);
        button.dataset.tagName = tag.name;
        button.dataset.tagCount = String(tag.task_count || 0);

        const label = document.createElement('span');
        label.className = 'tag-filter-label';
        label.textContent = `#${tag.name}`;

        const remove = document.createElement('span');
        remove.className = 'tag-filter-remove';
        remove.setAttribute('role', 'button');
        remove.setAttribute('tabindex', '0');
        remove.setAttribute('aria-label', `Delete tag #${tag.name}`);
        remove.dataset.tagId = String(tag.id);

        const icon = document.createElement('i');
        icon.className = 'bi bi-x-lg';
        remove.appendChild(icon);

        button.append(label, remove);
        return button;
    }

    function ensureTagInFilter(tag) {
        if (!filterContainer || !tag) {
            return;
        }
        const tagId = String(tag.id);
        const normalized = {
            id: Number(tag.id),
            name: tag.name,
            task_count: Number(tag.task_count ?? tag.taskCount ?? tag.count ?? 0),
        };
        const existing = availableTagsMap.get(tagId);
        if (existing) {
            existing.task_count = normalized.task_count;
            const button = filterContainer.querySelector(`.tag-filter-button[data-tag-id="${tagId}"]`);
            if (button) {
                button.dataset.tagCount = String(existing.task_count);
            }
            return;
        }
        availableTagsMap.set(tagId, normalized);
        const button = createFilterButton(normalized);
        filterContainer.appendChild(button);
        updateFilterEmptyState();
    }

    function adjustFilterTagCount(tagId, delta) {
        if (!filterContainer) {
            return;
        }
        const button = filterContainer.querySelector(`.tag-filter-button[data-tag-id="${tagId}"]`);
        if (!button) {
            return;
        }
        const current = Number(button.dataset.tagCount || '0');
        const next = Math.max(0, current + delta);
        button.dataset.tagCount = String(next);
        const tag = availableTagsMap.get(String(tagId));
        if (tag) {
            tag.task_count = next;
        }
    }

    function updateTaskTagDisplay(taskId, tags) {
        const container = document.getElementById(`task-tags-${taskId}`);
        if (container) {
            container.innerHTML = '';
            tags.forEach((tag) => {
                const pill = document.createElement('span');
                pill.className = 'tag-pill';
                pill.dataset.tagId = tag.id;
                pill.dataset.tagName = tag.name;
                pill.textContent = `#${tag.name}`;
                container.appendChild(pill);
            });
        }

        const taskWrapper = document.querySelector(`.task-item[data-task-id="${taskId}"]`);
        if (taskWrapper) {
            const tagIds = tags.map((tag) => tag.id);
            taskWrapper.dataset.tagIds = tagIds.join(',');
        }
    }

    function renderTagOptions() {
        if (!tagModalAvailable) {
            return;
        }

        hydrateAvailableTagsFromFilter();
        currentTaskTags.forEach((tag) => ensureTagInFilter(tag));

        tagModalAvailable.innerHTML = '';
        const tags = Array.from(availableTagsMap.values()).sort((a, b) => a.name.localeCompare(b.name));

        if (tags.length === 0) {
            if (tagModalEmpty) {
                tagModalEmpty.classList.remove('d-none');
            }
            return;
        }

        if (tagModalEmpty) {
            tagModalEmpty.classList.add('d-none');
        }

        tags.forEach((tag) => {
            const chip = document.createElement('button');
            chip.type = 'button';
            chip.className = 'btn btn-sm tag-chip';
            chip.dataset.tagId = tag.id;
            chip.textContent = `#${tag.name}`;
            if (currentTaskTags.has(String(tag.id))) {
                chip.classList.add('active', 'assigned');
            }
            chip.addEventListener('click', () => toggleTagAssignment(tag));
            tagModalAvailable.appendChild(chip);
        });
    }

    function toggleTagAssignment(tag) {
        const tagId = String(tag.id);
        if (currentTaskTags.has(tagId)) {
            updateTagAssignment(tagId, false);
        } else {
            updateTagAssignment(tagId, true);
        }
    }

    function updateTagAssignment(tagId, assign) {
        if (!currentTaskId || !csrfToken) {
            return;
        }

        const url = assign ? `/tasks/${currentTaskId}/tags` : `/tasks/${currentTaskId}/tags/${tagId}`;
        const options = {
            method: assign ? 'POST' : 'DELETE',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrfToken,
            },
        };

        if (assign) {
            options.body = JSON.stringify({ tag_id: Number(tagId) });
        }

        fetch(url, options)
            .then((response) => {
                if (!response.ok) {
                    throw response;
                }
                return response.json();
            })
            .then((data) => {
                if (data && data.tag) {
                    const tag = data.tag;
                    const tagKey = String(tag.id);
                    if (assign) {
                        currentTaskTags.set(tagKey, tag);
                        ensureTagInFilter(tag);
                        adjustFilterTagCount(tagKey, 1);
                    } else {
                        currentTaskTags.delete(tagKey);
                        adjustFilterTagCount(tagKey, -1);
                    }
                    updateTaskTagDisplay(currentTaskId, Array.from(currentTaskTags.values()));
                    renderTagOptions();
                    renderInlineTagOptions();
                    if (getCurrentSortBy() === 'tags') {
                        refreshTaskList();
                    } else {
                        applyTagFilters();
                    }
                }
            })
            .catch((error) => {
                console.error('Unable to update tag assignment', error);
            });
    }

    function handleCreateTag() {
        if (!newTagInput || !currentTaskId) {
            return;
        }

        createTagOnServer(newTagInput.value)
            .then((tag) => {
                ensureTagInFilter(tag);
                newTagInput.value = '';
                if (newTagFeedback) {
                    newTagFeedback.classList.add('d-none');
                }
                const tagKey = String(tag.id);
                currentTaskTags.set(tagKey, tag);
                renderTagOptions();
                updateTagAssignment(tagKey, true);
            })
            .catch((error) => {
                if (newTagFeedback) {
                    const message = error && error.error ? error.error : 'Unable to create tag.';
                    newTagFeedback.textContent = message;
                    newTagFeedback.classList.remove('d-none');
                }
            });
    }

    function applyTagFilters() {
        const activeTags = filterContainer
            ? Array.from(filterContainer.querySelectorAll('.tag-filter-button.active')).map((button) => button.dataset.tagId)
            : [];

        const groupsContainer = getTaskGroupsContainer();
        const currentSort = groupsContainer ? groupsContainer.dataset.sortBy : null;

        document.querySelectorAll('.task-item').forEach((taskElement) => {
            const taskTags = (taskElement.dataset.tagIds || '').split(',').filter(Boolean);
            const matches = activeTags.every((tagId) => taskTags.includes(tagId));
            taskElement.style.display = matches ? '' : 'none';
        });

        document.querySelectorAll('.task-group').forEach((group) => {
            if (currentSort === 'tags') {
                const hasVisibleTask = Array.from(group.querySelectorAll('.task-item')).some((task) => task.style.display !== 'none');
                group.style.display = hasVisibleTask ? '' : 'none';
            } else {
                group.style.display = '';
            }
        });
    }

    const handleFilterContainerClick = (event) => {
        const removeTarget = event.target.closest('.tag-filter-remove');
        if (removeTarget) {
            event.preventDefault();
            const tagId = removeTarget.dataset.tagId;
            handleTagDelete(tagId, removeTarget);
            return;
        }
        const button = event.target.closest('.tag-filter-button');
        if (!button) {
            return;
        }
        event.preventDefault();
        handleFilterToggle(button);
    };

    function handleFilterToggle(button) {
        if (!button) {
            return;
        }
        button.classList.toggle('active');
        applyTagFilters();
    }

    const handleFilterRemoveKeydown = (event) => {
        if (event.key !== 'Enter' && event.key !== ' ') {
            return;
        }
        const removeTarget = event.target.closest('.tag-filter-remove');
        if (!removeTarget) {
            return;
        }
        event.preventDefault();
        handleTagDelete(removeTarget.dataset.tagId, removeTarget);
    };

    if (filterContainer) {
        filterContainer.addEventListener('click', handleFilterContainerClick);
        filterContainer.addEventListener('keydown', handleFilterRemoveKeydown);
    }

    if (filterClear) {
        filterClear.addEventListener('click', (event) => {
            event.preventDefault();
            filterContainer.querySelectorAll('.tag-filter-button').forEach((button) => {
                button.classList.remove('active');
            });
            applyTagFilters();
        });
    }

    function handleTagDelete(tagId, triggerElement) {
        if (!tagId || !csrfToken) {
            return;
        }
        const button = triggerElement
            ? triggerElement.closest('.tag-filter-button')
            : filterContainer
            ? filterContainer.querySelector(`.tag-filter-button[data-tag-id="${tagId}"]`)
            : null;
        if (!button) {
            return;
        }
        const tagName = button.dataset.tagName || '';
        const tagCount = Number(button.dataset.tagCount || '0');
        if (tagCount > 0) {
            const confirmed = window.confirm(
                `Tag "#${tagName}" is assigned to ${tagCount} task${tagCount === 1 ? '' : 's'}. Delete it?`
            );
            if (!confirmed) {
                return;
            }
        }
        fetch(`/tags/${tagId}`, {
            method: 'DELETE',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrfToken,
            },
        })
            .then((response) => {
                if (!response.ok) {
                    throw response;
                }
                return response.json();
            })
            .then(() => {
                button.remove();
                availableTagsMap.delete(String(tagId));
                updateFilterEmptyState();
                inlineSelectedTags.delete(String(tagId));
                syncInlineTagsField();
                renderInlineTagOptions();
                applyTagFilters();
                refreshTaskList();
            })
            .catch((error) => {
                console.error('Unable to delete tag', error);
            });
    }

    // Use WeakSet to track attached listeners for edit-task-btn
    const editTaskListenerAttached = new WeakSet();
    function attachEditTaskListeners() {
        document.querySelectorAll('.edit-task-btn').forEach((button) => {
            if (editTaskListenerAttached.has(button)) {
                return;
            }
            editTaskListenerAttached.add(button);
            button.addEventListener('click', (event) => {
                event.preventDefault();

                if (nameField) {
                    nameField.value = button.getAttribute('data-task-name') || '';
                }

                if (descriptionField) {
                    descriptionField.value = button.getAttribute('data-task-description') || '';
                    autoResizeTextarea(descriptionField);
                }

                if (endDateField) {
                    const rawDate = button.getAttribute('data-task-end_date');
                    endDateField.value = rawDate ? convertToLocal(rawDate) : '';
                }

                const tagString = button.getAttribute('data-task-tags') || '';
                if (tagsField) {
                    tagsField.value = tagString;
                }
                setInlineTagsFromString(tagString, button.getAttribute('data-task-id'));

                const baseUrl = '{{ url_for("edit_task", id=0) }}';
                const actionUrl = baseUrl.replace('/0', `/${button.getAttribute('data-task-id')}`);
                if (taskForm) {
                    taskForm.action = actionUrl;
                }

                expandAccordionItem('detailed-item-container');
                window.scrollTo({ top: 0, behavior: 'smooth' });
            });
        });
    }

    function attachTagManagerListeners() {
        document.querySelectorAll('.tag-manager-btn').forEach((button) => {
            if (button.dataset.tagManagerListenerAttached === 'true') {
                return;
            }
            button.dataset.tagManagerListenerAttached = 'true';
            button.addEventListener('click', (event) => {
                event.preventDefault();
                if (!tagModal) {
                    return;
                }

                currentTaskId = button.dataset.taskId;
                currentTaskTags = new Map();

                if (tagModalTaskName) {
                    tagModalTaskName.textContent = `Tags for "${button.dataset.taskName || ''}"`;
                }

                const tagContainer = document.getElementById(`task-tags-${currentTaskId}`);
                if (tagContainer) {
                    tagContainer.querySelectorAll('[data-tag-id]').forEach((pill) => {
                        const id = String(pill.dataset.tagId);
                        currentTaskTags.set(id, {
                            id: Number(id),
                            name: pill.dataset.tagName || pill.textContent.replace('#', '').trim(),
                        });
                    });
                }

                renderTagOptions();

                if (newTagInput) {
                    newTagInput.value = '';
                    newTagInput.focus({ preventScroll: true });
                }

                if (newTagFeedback) {
                    newTagFeedback.classList.add('d-none');
                }

                tagModal.show();
            });
        });
    }

    if (quickCancelBtn) {
        quickCancelBtn.addEventListener('click', () => {
            const actionUrl = '{{ url_for("add_task") }}';
            if (taskForm) {
                taskForm.action = actionUrl;
            }
            clearInlineSelection();
            collapseAccordionItem('detailed-item-container');
        });
    }

    if (taskForm) {
        taskForm.addEventListener('reset', () => {
            const actionUrl = '{{ url_for("add_task") }}';
            taskForm.action = actionUrl;
            clearInlineSelection();
            if (descriptionField) {
                descriptionField.style.height = '';
            }
        });
    }

    document.querySelectorAll('textarea.auto-resize-textarea').forEach((textarea) => {
        autoResizeTextarea(textarea);
        textarea.addEventListener('input', () => autoResizeTextarea(textarea));
    });

    function buildFilterUrl() {
        if (!filterForm) {
            return window.location.pathname;
        }
        const params = new URLSearchParams();
        const formData = new FormData(filterForm);
        formData.forEach((value, key) => {
            if (key === 'search') {
                const trimmed = (value || '').trim();
                if (!trimmed) {
                    return;
                }
                params.append(key, trimmed);
                return;
            }
            if (key === 'show_completed') {
                if (!filterCompleted || !filterCompleted.checked) {
                    return;
                }
            }
            if (value === null || value === undefined || value === '') {
                return;
            }
            params.append(key, value);
        });
        const queryString = params.toString();
        return `${filterForm.action}${queryString ? `?${queryString}` : ''}`;
    }

    function refreshTaskList() {
        if (!filterForm) {
            console.warn('refreshTaskList: filterForm is missing. Task list will not be updated.');
            return Promise.resolve();
        }
        const url = buildFilterUrl();
        history.replaceState(null, '', url);
        return fetch(url, {
            headers: {
                'X-Requested-With': 'XMLHttpRequest',
            },
        })
            .then((response) => {
                if (!response.ok) {
                    throw response;
                }
                return response.json();
            })
            .then((data) => {
                if (!data || typeof data.html !== 'string') {
                    return;
                }
                const template = document.createElement('template');
                template.innerHTML = data.html.trim();
                const newContainer = template.content.firstElementChild;
                const currentContainer = getTaskGroupsContainer();
                if (newContainer && currentContainer) {
                    currentContainer.replaceWith(newContainer);
                }
                hydrateAvailableTagsFromFilter();
                renderInlineTagOptions();
                initializeSortableGroups();
                attachEditTaskListeners();
                attachTagManagerListeners();
                syncChevronStates();
                updateDateDisplays();
                applyTagFilters();
            })
            .catch((error) => {
                console.error('Unable to refresh tasks', error);
            });
    }

    initializeSortableGroups();
    hydrateAvailableTagsFromFilter();
    setInlineTagsFromString(tagsField ? tagsField.value : '');
    attachEditTaskListeners();
    attachTagManagerListeners();
    applyTagFilters();
    updateDateDisplays();
    syncChevronStates();

    if (createTagBtn) {
        createTagBtn.addEventListener('click', handleCreateTag);
    }

    if (newTagInput) {
        newTagInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                event.preventDefault();
                handleCreateTag();
            }
        });
    }

    if (inlineTagAddBtn) {
        inlineTagAddBtn.addEventListener('click', handleInlineTagCreate);
    }

    if (inlineTagInput) {
        inlineTagInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                event.preventDefault();
                handleInlineTagCreate();
            }
        });
    }

    if (filterForm) {
        filterForm.addEventListener('submit', (event) => {
            event.preventDefault();
            refreshTaskList();
        });
    }

    if (sortSelect) {
        sortSelect.addEventListener('change', () => {
            refreshTaskList();
        });
    }

    if (filterCompleted) {
        filterCompleted.addEventListener('change', () => {
            refreshTaskList();
        });
    }

    if (searchInput) {
        const debouncedSearch = debounce(() => {
            refreshTaskList();
        }, 300);
        searchInput.addEventListener('input', () => {
            debouncedSearch();
        });
    }
</script>
{% endblock  %}
