{% extends 'app.html' %}

{% block title %}Tasks{% endblock %}

{% block css %}
{{ super() }}
<style>
    .tag-chip,
    .tag-pill {
        border-radius: 999px;
        padding: 0.25rem 0.75rem;
        font-size: var(--bs-body-font-size, 1rem);
        font-weight: 500;
        display: inline-flex;
        align-items: center;
        gap: 0.25rem;
        border: var(--bs-border-width, 1px) solid var(--bs-border-color);
        border-width: calc(var(--bs-border-width, 1px) * 1.1);
        transition: all 0.15s ease-in-out;
    }

    .tag-chip {
        cursor: pointer;
        background-color: transparent;
        color: var(--bs-body-color);
    }

    .tag-chip:hover {
        background-color: var(--bs-tertiary-bg);
    }

    .tag-chip.active,
    .tag-chip.assigned {
        background-color: var(--bs-primary);
        border-color: var(--bs-primary);
        color: var(--bs-white);
    }

    .tag-chip.assigned:not(.active) {
        background-color: var(--bs-secondary);
        border-color: var(--bs-secondary);
    }

    .tag-pill {
        background-color: var(--bs-tertiary-bg);
        color: var(--bs-secondary-color, var(--bs-secondary));
    }

    .task-group-header {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        margin-bottom: 0.5rem;
        flex-wrap: wrap;
    }

    .task-group-title {
        margin-bottom: 0;
    }

    .task-group-action-buttons {
        display: inline-flex;
        align-items: center;
        gap: 0.25rem;
    }

    .quick-task-input {
        height: 2.75rem;
        min-height: 2.75rem;
        max-height: 12rem;
        resize: none;
        overflow: hidden;
        transition: height 0.25s ease, min-height 0.25s ease;
    }

    .quick-task-input.quick-task-input--expanded {
        min-height: 3.25rem;
    }

    .quick-task-input.quick-task-input--overflow {
        overflow-y: auto;
    }

    .task-description-input {
        height: 5.5rem;
        min-height: 5.5rem;
        max-height: 80vh;
        resize: none;
        overflow: hidden;
        transition: height 0.25s ease, min-height 0.25s ease;
    }

    .task-description-input.task-description-input--expanded {
        min-height: 6.25rem;
    }

    .task-description-input.task-description-input--overflow {
        overflow-y: auto;
    }

    .task-item-header {
        display: flex;
        flex-wrap: wrap;
        align-items: flex-start;
        column-gap: 0.5rem;
        row-gap: 0.35rem;
        width: 100%;
    }

    .task-toggle {
        min-width: 0;
        color: var(--bs-secondary-color, var(--bs-body-color));
        transition: color 0.15s ease-in-out;
    }

    .task-toggle:hover,
    .task-toggle:focus {
        color: var(--bs-body-color);
    }

    .task-title del {
        color: inherit;
    }

    .github-issue-badge {
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        padding: 0.25rem 0.5rem;
        background-color: var(--bs-light);
        border: 1px solid var(--bs-border-color);
        border-radius: 1rem;
        text-decoration: none;
        font-size: 0.75rem;
        font-weight: 600;
        color: var(--bs-secondary);
        transition: all 0.15s ease-in-out;
        white-space: nowrap;
        flex-shrink: 0;
    }

    .github-issue-badge:hover {
        background-color: var(--bs-primary);
        border-color: var(--bs-primary);
        color: var(--bs-white);
        text-decoration: none;
    }

    .github-issue-badge i {
        font-size: 0.65rem;
    }

    [data-bs-theme="dark"] .github-issue-badge {
        background-color: rgba(255, 255, 255, 0.06);
        border-color: rgba(255, 255, 255, 0.18);
        color: var(--bs-gray-200);
    }

    [data-bs-theme="dark"] .github-issue-badge i {
        color: inherit;
    }

    [data-bs-theme="dark"] .github-issue-badge:hover {
        background-color: rgba(255, 255, 255, 0.12);
        border-color: rgba(255, 255, 255, 0.24);
        color: var(--bs-white);
    }

    .task-github-pill-group {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        flex-shrink: 0;
        max-width: 100%;
    }

    .github-milestone-pill {
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        padding: 0.25rem 0.5rem;
        background-color: var(--bs-light);
        border: 1px solid var(--bs-border-color);
        border-radius: 1rem;
        font-size: 0.75rem;
        font-weight: 600;
        color: var(--bs-secondary);
        transition: all 0.15s ease-in-out;
        white-space: nowrap;
    }

    .github-milestone-pill:hover,
    .github-milestone-pill:focus {
        background-color: var(--bs-primary);
        border-color: var(--bs-primary);
        color: var(--bs-white);
        text-decoration: none;
    }

    .github-milestone-pill i {
        font-size: 0.65rem;
    }

    .github-milestone-pill .milestone-name {
        max-width: 9rem;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    [data-bs-theme="dark"] .github-milestone-pill {
        background-color: rgba(255, 255, 255, 0.06);
        border-color: rgba(255, 255, 255, 0.18);
        color: var(--bs-gray-200);
    }

    [data-bs-theme="dark"] .github-milestone-pill i {
        color: inherit;
    }

    [data-bs-theme="dark"] .github-milestone-pill:hover,
    [data-bs-theme="dark"] .github-milestone-pill:focus {
        background-color: rgba(255, 255, 255, 0.12);
        border-color: rgba(255, 255, 255, 0.24);
        color: var(--bs-white);
    }

    .task-action-group {
        display: flex;
        align-items: center;
        gap: 0.25rem;
        margin-left: auto;
        flex-shrink: 0;
    }

    .task-title-container {
        display: flex;
        align-items: flex-start;
        flex-grow: 1;
        min-width: 0;
        gap: 0.5rem;
    }

    .task-name {
        flex-shrink: 1;
        word-break: break-word;
        color: var(--bs-secondary-color, var(--bs-body-color));
        font-weight: 500;
        text-align: left;
    }

    .task-toggle {
        min-width: 0;
        color: var(--bs-secondary-color, var(--bs-body-color));
        transition: color 0.15s ease-in-out;
        text-align: left;
        flex-shrink: 1;
        text-decoration: none;
    }

    /* On smaller screens, move actions to new line */
    @media (max-width: 767px) {
        .task-item-header {
            flex-direction: column;
            align-items: stretch;
        }

        .task-action-group {
            margin-left: 0;
            justify-content: flex-end;
            margin-top: 0.25rem;
        }

        .task-title-container {
            width: 100%;
        }
    }

    /* Medium screens (tablets) */
    @media (min-width: 768px) and (max-width: 991px) {
        .task-item-header {
            flex-direction: row;
            flex-wrap: wrap;
        }

        .task-action-group {
            margin-left: auto;
            margin-top: 0;
        }
    }

    .tag-section-label {
        font-size: 0.8rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: var(--bs-secondary-color, var(--bs-secondary));
    }

    .tag-filter-toolbar {
        background-color: var(--bs-body-bg);
        border-radius: 0.75rem;
        border: 1px solid var(--bs-border-color);
        padding: 0.75rem 1rem;
    }

    .drag-disabled {
        opacity: 0.35;
        cursor: default !important;
        pointer-events: none;
    }

    .btn-pastel-success,
    .btn-pastel-danger {
        border-width: 1px;
        border-style: solid;
        transition: all 0.15s ease-in-out;
        color: var(--bs-body-color);
        border-color: var(--bs-secondary-border-subtle, #ced4da);
        background-color: var(--bs-tertiary-bg);
    }

    .btn-pastel-success:hover,
    .btn-pastel-success:focus,
    .btn-pastel-danger:hover,
    .btn-pastel-danger:focus {
        color: var(--bs-body-color);
        border-color: var(--bs-secondary-color, #adb5bd);
        background-color: var(--bs-secondary-bg, #e9ecef);
    }

    .task-description {
        white-space: pre-wrap;
        color: var(--bs-secondary-color, var(--bs-body-color));
    }

    .inline-tag-input-group .form-control {
        min-height: 2.5rem;
    }

    #tag-filter-clear {
        border: none;
        background: transparent;
        color: var(--bs-secondary-color, var(--bs-secondary));
        display: inline-flex;
        align-items: center;
        padding: 0;
    }

    #tag-filter-clear:hover,
    #tag-filter-clear:focus {
        color: var(--bs-body-color);
    }

    .task-meta {
        font-size: 0.8rem;
        color: var(--bs-secondary-color, var(--bs-secondary));
    }

    .task-tags:empty {
        display: none;
    }

    .inline-tag-chip {
        border-radius: 999px;
        padding: 0.25rem 0.75rem;
        border: var(--bs-border-width, 1px) solid var(--bs-border-color);
        border-width: calc(var(--bs-border-width, 1px) * 1.1);
        font-size: var(--bs-body-font-size, 1rem);
        font-weight: 500;
        background-color: var(--bs-body-bg);
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        gap: 0.25rem;
    }

    .inline-tag-chip.active {
        background-color: var(--bs-primary);
        color: var(--bs-white);
        border-color: var(--bs-primary);
    }

    .inline-tag-chip.auto-applied {
        box-shadow: 0 0 0 0.2rem rgba(var(--bs-primary-rgb, 13, 110, 253), 0.2);
    }

    [data-bs-theme="dark"] .inline-tag-chip.auto-applied {
        box-shadow: 0 0 0 0.2rem rgba(13, 110, 253, 0.35);
    }

    .tag-filter-button {
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
    }

    .tag-filter-label {
        display: inline-flex;
        align-items: center;
    }

    .tag-filter-remove {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 1.25rem;
        height: 1.25rem;
        border-radius: 999px;
        cursor: pointer;
        color: inherit;
    }

    .tag-filter-remove:hover,
    .tag-filter-remove:focus {
        background-color: rgba(0, 0, 0, 0.08);
    }

    .tag-filter-button .tag-filter-remove i {
        pointer-events: none;
    }

    .task-action-btn {
        border: var(--bs-border-width, 1px) solid var(--bs-border-color);
        background-color: var(--bs-tertiary-bg);
        color: var(--bs-body-color);
        transition: all 0.15s ease-in-out;
        padding: 0.25rem 0.45rem;
        font-size: 0.85rem;
        line-height: 1;
        display: inline-flex;
        align-items: center;
        justify-content: center;
    }

    .task-action-btn:hover,
    .task-action-btn:focus {
        background-color: var(--bs-secondary-bg, #e9ecef);
        border-color: var(--bs-secondary-border-subtle, #ced4da);
        color: var(--bs-body-color);
    }

    .task-action-group {
        display: flex;
        flex-wrap: nowrap;
        gap: 0.35rem;
        margin-left: auto;
        justify-content: flex-end;
        flex: 0 0 auto;
        white-space: nowrap;
        align-self: center;
    }

    .task-action-group .task-action-btn {
        border-radius: 0.5rem;
    }

    @media (max-width: 767.98px) {
        .task-action-group {
            width: 100%;
            margin-left: 0;
            justify-content: flex-start;
        }
    }

    .task-group-copy-btn,
    .task-group-add-btn {
        --task-quick-add-scale: 0.75;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 0.25rem;
        --bs-btn-padding-y: calc(0.25rem * var(--task-quick-add-scale));
        --bs-btn-padding-x: calc(0.5rem * var(--task-quick-add-scale));
        --bs-btn-font-size: calc(0.875rem * var(--task-quick-add-scale));
        --bs-btn-line-height: 1;
        --bs-btn-border-radius: calc(0.2rem * var(--task-quick-add-scale));
    }

    .task-group-copy-btn .bi,
    .task-group-add-btn .bi {
        font-size: calc(1rem * var(--task-quick-add-scale));
    }

    [data-bs-theme="dark"] .task-group-copy-btn,
    [data-bs-theme="dark"] .task-group-add-btn {
        --bs-btn-color: var(--bs-white);
        --bs-btn-border-color: rgba(255, 255, 255, 0.65);
        --bs-btn-hover-color: var(--bs-white);
        --bs-btn-hover-bg: rgba(255, 255, 255, 0.2);
        --bs-btn-hover-border-color: rgba(255, 255, 255, 0.85);
        --bs-btn-active-bg: rgba(255, 255, 255, 0.3);
        --bs-btn-active-border-color: rgba(255, 255, 255, 0.9);
        color: var(--bs-white);
    }

    .task-filter-collapse.collapse:not(.show) {
        display: none;
    }

    @media (min-width: 992px) {
        .task-item-header {
            flex-wrap: nowrap;
            flex-direction: row;
        }

        .task-action-group {
            margin-left: auto;
            margin-top: 0;
        }

        .task-filter-collapse.collapse {
            display: block !important;
            height: auto !important;
            visibility: visible;
        }
    }
</style>
{% endblock %}

{% block content %}

<div class="container">
    <div class="d-flex justify-content-end mb-2 d-lg-none">
        <button class="btn btn-outline-secondary btn-sm" type="button" data-task-filter-toggle data-bs-toggle="collapse" data-bs-target="#task-filter-collapse" aria-expanded="false" aria-controls="task-filter-collapse">
            Filters
            <i class="bi bi-sliders"></i>
        </button>
    </div>
    <div id="task-filter-collapse" class="collapse task-filter-collapse">
        <div class="tag-filter-toolbar d-flex flex-column gap-3">
            <form action="{{ url_for('task') }}" method="get" class="row g-3 align-items-end" id="task-filter-form">
            <div class="col-12 col-md-4">
                <label for="search" class="form-label">Search tasks</label>
                <input type="search" class="form-control form-control-sm" id="search" name="search" value="{{ search_query }}" placeholder="Search by name or description" autocomplete="off">
            </div>
            <div class="col-12 col-md-3">
                <label for="sort_by" class="form-label">Sort by</label>
                <select class="form-select form-select-sm" id="sort_by" name="sort_by">
                    <option value="rank" {{ 'selected' if sort_by == 'rank' else '' }}>Rank</option>
                    <option value="name" {{ 'selected' if sort_by == 'name' else '' }}>Name</option>
                    <option value="tags" {{ 'selected' if sort_by == 'tags' else '' }}>Tags</option>
                    <option value="due_date" {{ 'selected' if sort_by == 'due_date' else '' }}>Due date</option>
                </select>
            </div>
            <div class="col-12 col-md-3">
                <div class="form-check form-switch mt-md-4 pt-1">
                    <input class="form-check-input" type="checkbox" role="switch" id="filter-completed" name="show_completed" value="true" {{ 'checked' if show_completed else '' }}>
                    <label class="form-check-label" for="filter-completed">Show completed tasks</label>
                </div>
            </div>
            </form>
            <div class="d-flex flex-column flex-lg-row gap-2 align-items-lg-center">
                <div class="d-flex align-items-center gap-2">
                    <span class="tag-section-label mb-0">Tags:</span>
                    <button type="button" class="btn btn-sm" id="tag-filter-clear" aria-label="Clear tag filters">
                        <i class="bi bi-x-circle"></i>
                    </button>
                </div>
                <div class="d-flex flex-wrap gap-2" id="tag-filter-container">
                    {% for tag in available_tags %}
                        <button type="button" class="btn btn-sm tag-chip tag-filter-button" data-tag-id="{{ tag.id }}" data-tag-name="{{ tag.name | e }}" data-tag-count="{{ tag_usage.get(tag.id, 0) }}">
                            <span class="tag-filter-label">#{{ tag.name }}</span>
                            <span class="tag-filter-remove" role="button" tabindex="0" aria-label="Delete tag #{{ tag.name }}" data-tag-id="{{ tag.id }}">
                                <i class="bi bi-x-lg"></i>
                            </span>
                        </button>
                    {% endfor %}
                </div>
                <p class="text-muted mb-0 small {% if available_tags %}d-none{% endif %}" id="tag-filter-empty">
                    No tags yet. Add tags to tasks to start filtering.
                </p>
            </div>
        </div>
    </div>
</div>

<div class="container mt-2">
    <form id="task-form" method="post" action="{{ url_for('add_task') }}">
        {{ task_form.hidden_tag() }}
        {{ task_form.tags() }}
        <div  class="accordion" id="quick-item-accordion">
            <div class="input-group mb-3">
                <span class="input-group-text clickable-icon collapsed" data-bs-toggle="collapse" data-bs-target="#detailed-item-container">
                    <i class="bi bi-chevron-down text-muted"></i>
                </span>
                {{ task_form.name(
                    class_='form-control quick-task-input' + (' is-invalid' if task_form.name.errors else ''),
                    placeholder_="Add new task...",
                    rows=1,
                    data_auto_resize="quick-task-input",
                    data_collapsed_height="44",
                    data_auto_resize_max="192",
                    data_expanded_class="quick-task-input--expanded",
                    data_overflow_class="quick-task-input--overflow"
                ) }}
                <button id="quick-cancel-btn" class="btn btn-outline-secondary" type="reset">
                    <i class="bi bi-x-circle"></i>
                </button>
                <button id="quick-add-btn" class="btn btn-primary" type="submit">
                    <i class="bi bi-floppy"></i>
                </button>
                {% set name_error = task_form.name.errors[0] if task_form.name.errors else '' %}
                <div class="invalid-feedback {% if not name_error %}d-none{% endif %}" data-feedback-for="name">{{ name_error }}</div>
            </div>
        </div>
        <div id="detailed-item-container" class="accordion-collapse collapse" data-bs-parent="#quick-item-accordion">
            <div class="accordion-body">
                <div class="form-floating mb-3">
                    {{ task_form.description(
                        class_='form-control task-description-input' + (' is-invalid' if task_form.description.errors else ''),
                        rows=1,
                        placeholder_='Add more details',
                        data_auto_resize="task-description",
                        data_collapsed_height="88",
                        data_max_viewport_ratio="0.8",
                        data_expanded_class="task-description-input--expanded",
                        data_overflow_class="task-description-input--overflow"
                    ) }}
                    {{ task_form.description.label(class_='form-label') }}
                    {% set description_error = task_form.description.errors[0] if task_form.description.errors else '' %}
                    <div class="invalid-feedback {% if not description_error %}d-none{% endif %}" data-feedback-for="description">{{ description_error }}</div>
                </div>
                <div class="form-floating mb-3">
                    {{ task_form.end_date(class_='form-control'+ (' is-invalid' if task_form.end_date.errors else ''), placeholder_='YYYY-MM-DD') }}
                    {{ task_form.end_date.label(class_='form-label') }}
                    {% set end_date_error = task_form.end_date.errors[0] if task_form.end_date.errors else '' %}
                    <div class="invalid-feedback {% if not end_date_error %}d-none{% endif %}" data-feedback-for="end_date">{{ end_date_error }}</div>
                </div>
                <div class="mb-3 d-none" id="task-github-milestone-container" data-github-milestone-container>
                    <label class="form-label" for="task-github-milestone-select">GitHub Milestone</label>
                    {{ task_form.github_milestone(class_='form-select', id='task-github-milestone-select', **{'data-field': 'github_milestone'}) }}
                    <div class="form-text">Update the milestone assigned to the linked GitHub issue.</div>
                </div>
                <div class="alert alert-warning py-2 px-3 d-none" data-task-github-milestone-warning role="alert">
                    Unable to load milestones for this repository. Ensure your GitHub token includes milestone access.
                </div>
                <div class="mb-3">
                    <div class="d-flex flex-wrap gap-2" id="task-inline-tag-options"></div>
                    <p class="text-muted small mb-2 d-none" id="task-inline-tag-empty">No tags yet. Create one below.</p>
                    <div class="input-group input-group-sm inline-tag-input-group mt-3">
                        <span class="input-group-text">#</span>
                        <input type="text" class="form-control" id="task-inline-tag-input" placeholder="Add a tag and press Enter">
                        <button class="btn btn-outline-primary" type="button" id="task-inline-tag-add">Add</button>
                    </div>
                    <div class="invalid-feedback d-none" id="task-inline-tag-feedback">Please enter a tag name.</div>
                </div>
            </div>
        </div>
    </form>
</div>

{% include 'components/task_groups.html' %}
{% endblock %}

{% block modals %}
    {{ super() }}
    <div class="modal fade" id="tagManagerModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Manage tags</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <p class="text-muted small mb-1">Assign or remove tags to keep this task organized.</p>
                    <p class="fw-semibold mb-3" id="tag-modal-task-name"></p>
                    <div class="mb-3">
                        <div class="d-flex flex-wrap gap-2" id="tag-modal-available"></div>
                        <p class="text-muted small mb-0 d-none" id="tag-modal-empty">No tags yet. Create one below.</p>
                    </div>
                    <div class="input-group">
                        <span class="input-group-text">#</span>
                        <input type="text" class="form-control" id="new-tag-input" placeholder="Create a new tag">
                        <button class="btn btn-outline-primary" id="create-tag-btn" type="button">Add</button>
                    </div>
                    <div class="invalid-feedback d-none" id="new-tag-feedback">Please enter a tag name.</div>
                </div>
            </div>
        </div>
    </div>
    <div class="modal fade" id="taskMilestoneModal" tabindex="-1" aria-hidden="true" data-github-milestone-modal>
        <div class="modal-dialog modal-dialog-centered modal-dialog-scrollable">
            <div class="modal-content">
                <div class="modal-header">
                    <div>
                        <h5 class="modal-title mb-0">Update milestone</h5>
                        <p class="text-muted small mb-0" data-milestone-task-name></p>
                    </div>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <p class="text-muted small mb-3">Select a milestone to assign to the linked GitHub issue.</p>
                    <div class="alert alert-warning d-none" role="alert" data-milestone-error></div>
                    <div class="d-flex justify-content-center py-5" data-milestone-loading>
                        <div class="spinner-border text-primary" role="status" aria-hidden="true"></div>
                        <span class="visually-hidden">Loading milestones...</span>
                    </div>
                    <div class="list-group d-none" data-milestone-options></div>
                    <p class="text-muted small mt-3 d-none" data-milestone-empty>No milestones available for this repository.</p>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-outline-secondary" data-milestone-cancel data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" data-milestone-confirm disabled>Confirm</button>
                </div>
            </div>
        </div>
    </div>
{% endblock modals %}

{% block scripts %}
{{ super() }}
<script>
    const GITHUB_LOCAL_TAG_NAME = {{ github_local_tag_name|tojson }};
    const GITHUB_ISSUE_MISSING_MESSAGE = {{ github_issue_missing_message|tojson }};
    function debounce(fn, delay = 300) {
        let timeoutId;
        return (...args) => {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(() => fn.apply(null, args), delay);
        };
    }

    function getTaskGroupsContainer() {
        return document.getElementById('task-groups-container');
    }

    function initializeSortableGroups() {
        const container = getTaskGroupsContainer();
        if (!container) {
            return;
        }
        let sortableGroupIds = [];
        try {
            sortableGroupIds = JSON.parse(container.dataset.sortableGroups || '[]');
        } catch (error) {
            sortableGroupIds = [];
        }
        if (Array.isArray(sortableGroupIds)) {
            sortableGroupIds.forEach((groupId) => {
                initializeSortable(groupId, 'task');
            });
        }
    }

    function getCurrentSortBy() {
        const container = getTaskGroupsContainer();
        return container ? container.dataset.sortBy || null : null;
    }

    const defaultTaskAction = '{{ url_for("add_task") }}';
    const taskForm = document.getElementById('task-form');
    const quickAddBtn = document.getElementById('quick-add-btn');
    const quickCancelBtn = document.getElementById('quick-cancel-btn');
    const nameField = document.getElementById('name');
    const descriptionField = document.getElementById('description');

    Array.from(document.querySelectorAll('textarea[data-auto-resize]')).forEach((textarea) => {
        initializeAutoResizingTextarea(textarea);
    });

    const nameFieldAutoResize = nameField && nameField.__autoResizeController
        ? nameField.__autoResizeController
        : null;
    const descriptionFieldAutoResize = descriptionField && descriptionField.__autoResizeController
        ? descriptionField.__autoResizeController
        : null;
    const endDateField = document.getElementById('end_date');
    const githubMilestoneContainer = document.querySelector('[data-github-milestone-container]');
    const githubMilestoneSelect = document.getElementById('task-github-milestone-select');
    const githubMilestoneWarning = document.querySelector('[data-task-github-milestone-warning]');
    const milestoneModalElement = document.getElementById('taskMilestoneModal');
    const milestoneModalTaskName = milestoneModalElement
        ? milestoneModalElement.querySelector('[data-milestone-task-name]')
        : null;
    const milestoneModalOptions = milestoneModalElement
        ? milestoneModalElement.querySelector('[data-milestone-options]')
        : null;
    const milestoneModalLoading = milestoneModalElement
        ? milestoneModalElement.querySelector('[data-milestone-loading]')
        : null;
    const milestoneModalError = milestoneModalElement
        ? milestoneModalElement.querySelector('[data-milestone-error]')
        : null;
    const milestoneModalEmpty = milestoneModalElement
        ? milestoneModalElement.querySelector('[data-milestone-empty]')
        : null;
    const milestoneModalConfirm = milestoneModalElement
        ? milestoneModalElement.querySelector('[data-milestone-confirm]')
        : null;
    const milestoneModalInstance = milestoneModalElement
        ? new bootstrap.Modal(milestoneModalElement)
        : null;
    const milestoneTooltipInstances = new WeakMap();
    const tagsField = document.getElementById('tags');
    const inlineTagOptions = document.getElementById('task-inline-tag-options');
    const inlineTagEmpty = document.getElementById('task-inline-tag-empty');
    const inlineTagInput = document.getElementById('task-inline-tag-input');
    const inlineTagAddBtn = document.getElementById('task-inline-tag-add');
    const inlineTagFeedback = document.getElementById('task-inline-tag-feedback');

    const detailedItemContainer = document.getElementById('detailed-item-container');
    const quickToggleIcon = document.querySelector('[data-bs-target="#detailed-item-container"] i');
    const detailedItemCollapse = detailedItemContainer ? new bootstrap.Collapse(detailedItemContainer, { toggle: false }) : null;

    const filterForm = document.getElementById('task-filter-form');
    const searchInput = document.getElementById('search');
    const sortSelect = document.getElementById('sort_by');
    const filterCompleted = document.getElementById('filter-completed');
    const filterContainer = document.getElementById('tag-filter-container');
    const filterClear = document.getElementById('tag-filter-clear');
    const filterEmptyMessage = document.getElementById('tag-filter-empty');
    const filterCollapseElement = document.getElementById('task-filter-collapse');
    const filterToggleButtons = document.querySelectorAll('[data-task-filter-toggle]');
    const filterCollapse = filterCollapseElement ? new bootstrap.Collapse(filterCollapseElement, { toggle: false }) : null;
    const filterMediaQuery = window.matchMedia('(min-width: 992px)');

    // Use shared preferences utilities from preferences.js
    // Derive the active scope id from the DOM (task-groups-container data attribute)
    // instead of embedding server-side templating into the JS.
    const ACTIVE_SCOPE_ID = (function () {
        const container = getTaskGroupsContainer();
        if (!container) {
            return null;
        }
        const id = container.dataset.scopeId;
        if (!id || id === 'null' || id === 'undefined') {
            return null;
        }
        return String(id);
    })();

    function getCurrentScopeId() {
        const container = getTaskGroupsContainer();
        if (container) {
            const { scopeId } = container.dataset;
            if (scopeId && scopeId !== 'null' && scopeId !== 'undefined') {
                return scopeId;
            }
        }
        if (ACTIVE_SCOPE_ID !== null && ACTIVE_SCOPE_ID !== undefined) {
            return String(ACTIVE_SCOPE_ID);
        }
        return null;
    }

    const TASK_SCOPE_GITHUB = (function () {
        const container = getTaskGroupsContainer();
        if (!container) {
            return { owner: '', name: '', milestoneNumber: '', milestoneTitle: '' };
        }
        return {
            owner: container.dataset.scopeGithubOwner || '',
            name: container.dataset.scopeGithubName || '',
            milestoneNumber: container.dataset.scopeGithubMilestoneNumber || '',
            milestoneTitle: container.dataset.scopeGithubMilestoneTitle || '',
        };
    })();

    const milestoneCache = new Map();
    let activeMilestoneRequestKey = null;
    let activeMilestoneTask = null;
    let selectedMilestoneOption = null;

    function persistTaskPreferences() {
        const scopeId = getCurrentScopeId();
        if (!scopeId) {
            updatePreferenceData((data) => {
                data.lastScopeId = null;
                return data;
            });
            return;
        }
        const scopeKey = String(scopeId);
        const searchValue = searchInput ? (searchInput.value || '').trim() : '';
        const sortValue = sortSelect ? (sortSelect.value || '').trim() : '';
        const showCompletedValue = Boolean(filterCompleted && filterCompleted.checked);
        const activeTags = filterContainer
            ? Array.from(filterContainer.querySelectorAll('.tag-filter-button.active'))
                  .map((button) => String(button.dataset.tagId))
                  .filter((value) => value)
            : [];
        updatePreferenceData((data) => {
            data.lastScopeId = scopeKey;
            const existing = data.scopes[scopeKey];
            data.scopes[scopeKey] = {
                ...(existing && typeof existing === 'object' ? existing : {}),
                search: searchValue,
                sortBy: sortValue,
                showCompleted: showCompletedValue,
                tags: activeTags,
            };
            return data;
        });
    }

    function restoreTaskPreferences() {
        const scopeId = getCurrentScopeId();
        updatePreferenceData((data) => {
            data.lastScopeId = scopeId != null ? String(scopeId) : null;
            return data;
        });
        if (!scopeId) {
            return;
        }
        const stored = getStoredScopePreferences(scopeId);
        if (!stored) {
            persistTaskPreferences();
            return;
        }
        let shouldRefresh = false;
        if (searchInput && typeof stored.search === 'string') {
            const trimmed = stored.search;
            if (searchInput.value !== trimmed) {
                searchInput.value = trimmed;
                shouldRefresh = true;
            }
        }
        if (filterCompleted) {
            const desired = Boolean(stored.showCompleted);
            if (filterCompleted.checked !== desired) {
                filterCompleted.checked = desired;
                shouldRefresh = true;
            }
        }
        if (sortSelect && typeof stored.sortBy === 'string' && stored.sortBy) {
            const availableOptions = Array.from(sortSelect.options || []);
            if (availableOptions.some((option) => option.value === stored.sortBy) && sortSelect.value !== stored.sortBy) {
                sortSelect.value = stored.sortBy;
                shouldRefresh = true;
            }
        }

        let tagsChanged = false;
        let desiredTagCount = 0;
        if (filterContainer && Array.isArray(stored.tags)) {
            const desiredTags = stored.tags.map((value) => String(value)).filter((value) => value);
            desiredTagCount = desiredTags.length;
            const desiredSet = new Set(desiredTags);
            const buttons = Array.from(filterContainer.querySelectorAll('.tag-filter-button'));
            buttons.forEach((button) => {
                const tagId = button.dataset.tagId;
                const shouldBeActive = desiredSet.has(tagId);
                if (button.classList.contains('active') !== shouldBeActive) {
                    button.classList.toggle('active', shouldBeActive);
                    tagsChanged = true;
                }
            });
            if (tagsChanged || desiredTagCount > 0) {
                applyTagFilters();
            }
        }

        const refreshPromise = shouldRefresh ? refreshTaskList() : Promise.resolve();
        refreshPromise.finally(() => {
            if (!tagsChanged && desiredTagCount === 0) {
                applyTagFilters();
            }
            persistTaskPreferences();
            handleActiveFilterChange();
        });
    }

    if (detailedItemContainer && quickToggleIcon) {
        const setQuickToggleIcon = (isExpanded) => {
            quickToggleIcon.classList.toggle('bi-chevron-down', !isExpanded);
            quickToggleIcon.classList.toggle('bi-chevron-up', isExpanded);
        };
        setQuickToggleIcon(detailedItemContainer.classList.contains('show'));
        detailedItemContainer.addEventListener('show.bs.collapse', () => setQuickToggleIcon(true));
        detailedItemContainer.addEventListener('hide.bs.collapse', () => setQuickToggleIcon(false));
    }

    function getTaskFormAction() {
        if (!taskForm) {
            return defaultTaskAction;
        }
        return taskForm.getAttribute('action') || defaultTaskAction;
    }

    function isEditingCurrentTask() {
        const action = getTaskFormAction();
        return typeof action === 'string' && action.includes('/task/edit/');
    }

    function setTaskFormActionToAdd() {
        if (taskForm) {
            taskForm.action = defaultTaskAction;
        }
        editingTaskHasGithub = false;
    }

    function applyTaskFormErrors(errors = {}) {
        if (!taskForm) {
            return;
        }
        const fieldConfigs = [
            { element: nameField, key: 'name' },
            { element: descriptionField, key: 'description' },
            { element: endDateField, key: 'end_date' },
        ];

        fieldConfigs.forEach(({ element, key }) => {
            if (!element) {
                return;
            }
            const feedback = taskForm.querySelector(`[data-feedback-for="${key}"]`);
            const messages = Array.isArray(errors[key]) ? errors[key] : [];
            if (messages.length > 0) {
                element.classList.add('is-invalid');
                if (feedback) {
                    feedback.textContent = messages[0];
                    feedback.classList.remove('d-none');
                }
            } else {
                element.classList.remove('is-invalid');
                if (feedback) {
                    feedback.textContent = '';
                    feedback.classList.add('d-none');
                }
            }
        });
    }

    function convertToLocal(utcDateString) {
        if (!utcDateString) {
            return '';
        }
        const normalized = utcDateString.endsWith('Z') ? utcDateString : `${utcDateString}Z`;
        const date = new Date(normalized);
        if (Number.isNaN(date.getTime())) {
            return '';
        }

        const pad = (number) => (number < 10 ? `0${number}` : number);
        const yyyy = date.getFullYear();
        const MM = pad(date.getMonth() + 1);
        const dd = pad(date.getDate());
        const hh = pad(date.getHours());
        const mm = pad(date.getMinutes());

        return `${yyyy}-${MM}-${dd}T${hh}:${mm}`;
    }

    function formatDateTimeDisplay(utcDateString) {
        if (!utcDateString) {
            return '';
        }
        const normalized = utcDateString.endsWith('Z') ? utcDateString : `${utcDateString}Z`;
        const date = new Date(normalized);
        if (Number.isNaN(date.getTime())) {
            return '';
        }
        return date.toLocaleString(undefined, {
            year: 'numeric',
            month: 'short',
            day: 'numeric',
            hour: 'numeric',
            minute: 'numeric',
        });
    }

    function decodeHtmlEntities(text) {
        if (typeof text !== 'string' || !text) {
            return '';
        }
        const textarea = document.createElement('textarea');
        textarea.innerHTML = text;
        return textarea.value;
    }

    function parseJsonAttribute(value, fallback) {
        if (typeof value !== 'string' || !value.trim()) {
            return fallback;
        }
        try {
            return JSON.parse(value);
        } catch (error) {
            console.warn('Unable to parse JSON attribute', value, error);
            return fallback;
        }
    }

    function normalizeMultiline(text) {
        if (typeof text !== 'string') {
            return '';
        }
        return text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
    }

    function buildTaskClipboardDataFromElement(taskElement) {
        if (!(taskElement instanceof HTMLElement)) {
            return null;
        }
        const dataset = taskElement.dataset || {};
        const name = decodeHtmlEntities(dataset.taskName || '');
        const description = decodeHtmlEntities(dataset.taskDescription || '');
        const dueDate = dataset.taskDueDate || '';
        const completed = dataset.taskCompleted === 'true';
        const completedDate = dataset.taskCompletedDate || '';
        const tags = parseJsonAttribute(dataset.taskTags, []);
        const subtasks = parseJsonAttribute(dataset.taskSubtasks, []);

        const normalizedSubtasks = Array.isArray(subtasks)
            ? subtasks
                .map((subtask) => {
                    if (!subtask || typeof subtask !== 'object') {
                        return null;
                    }
                    const name = normalizeMultiline(decodeHtmlEntities(subtask.name || ''));
                    const description = normalizeMultiline(decodeHtmlEntities(subtask.description || ''));
                    return {
                        ...subtask,
                        name,
                        description,
                    };
                })
                .filter(Boolean)
            : [];

        return {
            id: dataset.taskId || '',
            name,
            description: normalizeMultiline(description),
            dueDate,
            completed,
            completedDate,
            tags: Array.isArray(tags) ? tags : [],
            subtasks: normalizedSubtasks,
        };
    }

    function copyTextToClipboard(text) {
        if (typeof text !== 'string' || !text.trim()) {
            return Promise.reject(new Error('Nothing to copy'));
        }
        if (navigator.clipboard && typeof navigator.clipboard.writeText === 'function') {
            return navigator.clipboard.writeText(text.trim());
        }

        return new Promise((resolve, reject) => {
            try {
                const textarea = document.createElement('textarea');
                textarea.value = text.trim();
                textarea.setAttribute('readonly', '');
                textarea.style.position = 'absolute';
                textarea.style.left = '-9999px';
                document.body.appendChild(textarea);
                textarea.select();
                const successful = document.execCommand('copy');
                document.body.removeChild(textarea);
                if (successful) {
                    resolve();
                } else {
                    reject(new Error('Copy command was unsuccessful'));
                }
            } catch (error) {
                reject(error);
            }
        });
    }

    function formatDateInputValue(date) {
        if (!(date instanceof Date) || Number.isNaN(date.getTime())) {
            return '';
        }
        const pad = (value) => (value < 10 ? `0${value}` : String(value));
        return `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())}T${pad(date.getHours())}:${pad(date.getMinutes())}`;
    }

    const DEFAULT_DUE_HOUR = 17;

    function computeDueDateForBucket(bucket) {
        if (!bucket) {
            return null;
        }
        const now = new Date();
        const target = new Date(now.getTime());
        target.setHours(DEFAULT_DUE_HOUR, 0, 0, 0);
        switch (bucket) {
            case 'today':
                return target;
            case 'tomorrow':
                target.setDate(target.getDate() + 1);
                return target;
            case 'next_week':
                target.setDate(target.getDate() + 7);
                return target;
            case 'next_month':
                target.setDate(target.getDate() + 30);
                return target;
            case 'future':
                target.setDate(target.getDate() + 60);
                return target;
            default:
                return null;
        }
    }

    function initializeAutoResizingTextarea(textarea) {
        if (!textarea) {
            return null;
        }
        if (textarea.__autoResizeController) {
            return textarea.__autoResizeController;
        }

        const dataset = textarea.dataset || {};
        const computedStyle = window.getComputedStyle(textarea);
        const fallbackCollapsedHeight = (() => {
            const lineHeight = parseFloat(computedStyle.lineHeight) || 0;
            const paddingTop = parseFloat(computedStyle.paddingTop) || 0;
            const paddingBottom = parseFloat(computedStyle.paddingBottom) || 0;
            const borderTop = parseFloat(computedStyle.borderTopWidth) || 0;
            const borderBottom = parseFloat(computedStyle.borderBottomWidth) || 0;
            const total = lineHeight + paddingTop + paddingBottom + borderTop + borderBottom;
            return total > 0 ? Math.ceil(total) : 44;
        })();
        const parsedCollapsed = parseInt(dataset.collapsedHeight || '', 10);
        const collapsedHeight = Math.max(
            Number.isFinite(parsedCollapsed) && parsedCollapsed > 0 ? parsedCollapsed : fallbackCollapsedHeight,
            1
        );

        const parsedMax = parseInt(dataset.autoResizeMax || '', 10);
        const explicitMaxHeight = Number.isFinite(parsedMax) && parsedMax > 0 ? parsedMax : Infinity;

        let viewportRatio = parseFloat(dataset.maxViewportRatio || '');
        if (Number.isFinite(viewportRatio)) {
            if (viewportRatio > 1) {
                viewportRatio /= 100;
            }
            if (viewportRatio <= 0) {
                viewportRatio = null;
            } else if (viewportRatio > 1) {
                viewportRatio = 1;
            }
        } else {
            viewportRatio = null;
        }

        const expandedClass = dataset.expandedClass || '';
        const overflowClass = dataset.overflowClass || '';

        const parseDuration = (value, fallback) => {
            const parsed = parseFloat(value);
            if (!Number.isFinite(parsed) || parsed < 0) {
                return fallback;
            }
            return parsed;
        };

        const collapseDuration = parseDuration(dataset.collapseDuration, 0.25);
        const expandDuration = parseDuration(dataset.expandDuration, collapseDuration);

        const applyTransition = (seconds) => {
            if (!Number.isFinite(seconds) || seconds <= 0) {
                textarea.style.transition = '';
                return;
            }
            const duration = Math.min(seconds, 5);
            textarea.style.transition = `height ${duration}s ease, min-height ${duration}s ease`;
        };

        const computeMaxHeight = () => {
            const viewportLimit = viewportRatio ? Math.floor(window.innerHeight * viewportRatio) : Infinity;
            const limit = Math.min(explicitMaxHeight, viewportLimit);
            if (!Number.isFinite(limit)) {
                return Infinity;
            }
            return Math.max(collapsedHeight, limit);
        };

        const setExpandedState = (isExpanded) => {
            if (!expandedClass) {
                return;
            }
            textarea.classList.toggle(expandedClass, Boolean(isExpanded));
        };

        const setOverflowState = (isOverflowing) => {
            if (overflowClass) {
                textarea.classList.toggle(overflowClass, Boolean(isOverflowing));
            }
            textarea.style.overflowY = isOverflowing ? 'auto' : 'hidden';
        };

        const collapse = () => {
            applyTransition(collapseDuration);
            setExpandedState(false);
            setOverflowState(false);
            textarea.style.minHeight = `${collapsedHeight}px`;
            const maxHeight = computeMaxHeight();
            textarea.style.maxHeight = Number.isFinite(maxHeight) ? `${maxHeight}px` : '';
            textarea.style.height = `${collapsedHeight}px`;
        };

        const expand = () => {
            applyTransition(expandDuration);
            setExpandedState(true);
            textarea.style.minHeight = `${collapsedHeight}px`;
            const maxHeight = computeMaxHeight();
            textarea.style.maxHeight = Number.isFinite(maxHeight) ? `${maxHeight}px` : '';
            
            // Get current height to animate from
            const currentHeight = textarea.offsetHeight;
            
            // Temporarily set height to auto to measure content, but make it invisible
            const previousTransition = textarea.style.transition;
            textarea.style.transition = 'none';
            textarea.style.height = 'auto';
            const fullHeight = textarea.scrollHeight;
            
            // Reset to current height before animating
            textarea.style.height = `${currentHeight}px`;
            
            // Force reflow to ensure the browser registers the height change
            textarea.offsetHeight;
            
            // Restore transition and animate to target height
            textarea.style.transition = previousTransition;
            const cap = Number.isFinite(maxHeight) ? maxHeight : fullHeight;
            const desiredHeight = Math.max(collapsedHeight, Math.min(fullHeight, cap));
            textarea.style.height = `${desiredHeight}px`;
            setOverflowState(Number.isFinite(maxHeight) && fullHeight > maxHeight);
        };

        const refresh = () => {
            if (document.activeElement === textarea) {
                expand();
            } else {
                collapse();
            }
        };

        const handleFocus = () => expand();
        const handleInput = () => expand();
        const handleBlur = () => collapse();
        const handleResize = () => refresh();
        const handleFormReset = () => window.requestAnimationFrame(() => collapse());

        textarea.style.resize = 'none';
        textarea.style.overflowY = 'hidden';
        applyTransition(collapseDuration);

        textarea.addEventListener('focus', handleFocus);
        textarea.addEventListener('input', handleInput);
        textarea.addEventListener('blur', handleBlur);
        window.addEventListener('resize', handleResize);

        const form = textarea.form;
        if (form) {
            form.addEventListener('reset', handleFormReset);
        }

        const controller = {
            refresh,
            expand,
            collapse,
            destroy() {
                textarea.removeEventListener('focus', handleFocus);
                textarea.removeEventListener('input', handleInput);
                textarea.removeEventListener('blur', handleBlur);
                window.removeEventListener('resize', handleResize);
                if (form) {
                    form.removeEventListener('reset', handleFormReset);
                }
                delete textarea.__autoResizeController;
            },
        };

        textarea.__autoResizeController = controller;
        refresh();
        return controller;
    }

    function selectDueDateBucket(bucket) {
        if (!endDateField) {
            return false;
        }
        if (!bucket) {
            endDateField.value = '';
            return false;
        }
        if (bucket === 'without_due') {
            endDateField.value = '';
            return true;
        }
        const target = computeDueDateForBucket(bucket);
        if (!target) {
            return false;
        }
        endDateField.value = formatDateInputValue(target);
        return true;
    }

    function syncInlineTagsField() {
        if (!tagsField) {
            return;
        }
        tagsField.value = Array.from(inlineSelectedTags.keys()).join(',');
    }

    function collectTagInfoForTask(taskId) {
        const info = new Map();
        if (!taskId) {
            return info;
        }
        const container = document.getElementById(`task-tags-${taskId}`);
        if (!container) {
            return info;
        }
        container.querySelectorAll('[data-tag-id]').forEach((pill) => {
            const id = String(pill.dataset.tagId);
            info.set(id, {
                id: Number(id),
                name: pill.dataset.tagName || pill.textContent.replace('#', '').trim(),
            });
        });
        return info;
    }

    function markAutoAppliedTags(tagIds = []) {
        const normalized = Array.isArray(tagIds)
            ? tagIds.map((value) => String(value).trim()).filter((value) => value)
            : [];
        autoAppliedTagIds = new Set(normalized);
    }

    function clearAutoAppliedTags() {
        autoAppliedTagIds = new Set();
    }

    function isGithubTagLike(tagId, fallbackName = '') {
        const key = String(tagId || '').trim();
        if (!key) {
            return false;
        }
        const stored = availableTagsMap.get(key);
        const name = stored && typeof stored.name === 'string' && stored.name
            ? stored.name
            : typeof fallbackName === 'string'
            ? fallbackName
            : '';
        if (!name) {
            return false;
        }
        if (typeof GITHUB_LOCAL_TAG_NAME !== 'string' || !GITHUB_LOCAL_TAG_NAME) {
            return false;
        }
        return name.trim().toLowerCase() === GITHUB_LOCAL_TAG_NAME.trim().toLowerCase();
    }

    function getActiveFilterTagIds() {
        if (!filterContainer) {
            return [];
        }
        return Array.from(filterContainer.querySelectorAll('.tag-filter-button.active'))
            .map((button) => ({
                id: String(button.dataset.tagId || '').trim(),
                name:
                    button.dataset.tagName ||
                    button.textContent.replace('#', '').trim(),
            }))
            .filter(({ id, name }) => id && !isGithubTagLike(id, name))
            .map(({ id }) => id);
    }

    function normalizeStoredTagEntry(entry) {
        if (!entry) {
            return null;
        }
        const rawId = entry.id != null ? String(entry.id) : String(entry);
        const id = (rawId || '').trim();
        if (!id) {
            return null;
        }
        const name = typeof entry.name === 'string' ? entry.name : '';
        if (isGithubTagLike(id, name)) {
            return null;
        }
        return { id, name };
    }

    function persistLastUsedTagsForScope(entries = []) {
        if (typeof setStoredLastTags !== 'function' || typeof clearStoredLastTags !== 'function') {
            return;
        }
        const scopeId = getCurrentScopeId();
        if (!scopeId) {
            return;
        }
        const normalized = Array.isArray(entries)
            ? entries
                  .map((entry) => normalizeStoredTagEntry(entry))
                  .filter(Boolean)
            : [];
        if (normalized.length === 0) {
            clearStoredLastTags(scopeId);
            return;
        }
        setStoredLastTags(scopeId, normalized);
    }

    function applyDefaultInlineTags(options = {}) {
        const { reason = '', skipFilters = false } = options || {};
        if (!taskForm || isEditingCurrentTask()) {
            return;
        }

        const scopeId = getCurrentScopeId();
        const storedRaw =
            scopeId && typeof getStoredLastTags === 'function'
                ? getStoredLastTags(scopeId)
                : [];
        const storedEntries = Array.isArray(storedRaw)
            ? storedRaw.map((entry) => normalizeStoredTagEntry(entry)).filter(Boolean)
            : [];

        const storedTagIds = [];
        storedEntries.forEach(({ id, name }) => {
            if (!availableTagsMap.has(id) && name) {
                const numericId = Number(id);
                if (!Number.isNaN(numericId)) {
                    ensureTagInFilter({ id: numericId, name, task_count: 0 });
                }
            }
            if (availableTagsMap.has(id)) {
                storedTagIds.push(id);
            }
        });

        const activeTagIds = skipFilters ? [] : getActiveFilterTagIds();
        if (activeTagIds.length > 0) {
            const activeSet = new Set(activeTagIds);
            const additionalIds = storedTagIds.filter((id) => !activeSet.has(id));
            const combined = [...activeTagIds, ...additionalIds];
            setInlineTagsFromString(combined.join(','));
            markAutoAppliedTags(combined);
            renderInlineTagOptions();
            return;
        }

        if (storedTagIds.length === 0) {
            clearAutoAppliedTags();
            setInlineTagsFromString('');
            renderInlineTagOptions();
            return;
        }

        setInlineTagsFromString(storedTagIds.join(','));
        markAutoAppliedTags(storedTagIds);
        renderInlineTagOptions();
    }

    function handleActiveFilterChange() {
        const activeTagIds = getActiveFilterTagIds();
        const signature = activeTagIds.slice().sort().join(',');
        const scopeId = getCurrentScopeId();
        const storageAvailable =
            typeof setStoredLastTags === 'function' && typeof clearStoredLastTags === 'function';
        if (signature !== lastFilterSignature) {
            lastFilterSignature = signature;
            if (storageAvailable && scopeId) {
                if (activeTagIds.length > 0) {
                    const entries = activeTagIds
                        .map((id) => {
                            const tag = availableTagsMap.get(String(id));
                            const name = tag && typeof tag.name === 'string' ? tag.name : '';
                            return normalizeStoredTagEntry({ id, name });
                        })
                        .filter(Boolean);
                    if (entries.length > 0) {
                        setStoredLastTags(scopeId, entries);
                    } else {
                        clearStoredLastTags(scopeId);
                    }
                } else {
                    // No active filters  preserve existing last-used tags
                }
            }
        }
        applyDefaultInlineTags({ reason: 'filters-updated' });
    }

    function setInlineTagsFromString(tagString, taskId = null) {
        clearAutoAppliedTags();
        inlineSelectedTags = new Map();
        if (!tagString) {
            syncInlineTagsField();
            renderInlineTagOptions();
            if (inlineTagFeedback) {
                inlineTagFeedback.classList.add('d-none');
            }
            return;
        }
        const tagInfo = collectTagInfoForTask(taskId);
        tagString.split(',').forEach((value) => {
            const trimmed = value.trim();
            if (!trimmed) {
                return;
            }
            let tag = availableTagsMap.get(trimmed);
            if (!tag) {
                tag = tagInfo.get(trimmed);
            }
            if (!tag) {
                tag = { id: Number(trimmed), name: trimmed };
            }
            inlineSelectedTags.set(String(tag.id), {
                id: Number(tag.id),
                name: tag.name || trimmed,
            });
            ensureTagInFilter(tag);
        });
        syncInlineTagsField();
        renderInlineTagOptions();
        if (inlineTagFeedback) {
            inlineTagFeedback.classList.add('d-none');
        }
    }

    function renderInlineTagOptions() {
        if (!inlineTagOptions) {
            return;
        }
        inlineTagOptions.innerHTML = '';
        const tags = Array.from(availableTagsMap.values()).sort((a, b) => a.name.localeCompare(b.name));
        if (tags.length === 0) {
            if (inlineTagEmpty) {
                inlineTagEmpty.classList.remove('d-none');
            }
            return;
        }
        if (inlineTagEmpty) {
            inlineTagEmpty.classList.add('d-none');
        }
        tags.forEach((tag) => {
            const chip = document.createElement('button');
            chip.type = 'button';
            chip.className = 'inline-tag-chip';
            const key = String(tag.id);
            chip.dataset.tagId = key;
            chip.textContent = `#${tag.name}`;
            if (inlineSelectedTags.has(key)) {
                chip.classList.add('active');
                if (autoAppliedTagIds.has(key)) {
                    chip.classList.add('auto-applied');
                }
            }
            const isGithubTag = (tag.name || '').toLowerCase() === GITHUB_LOCAL_TAG_NAME;
            if (isGithubTag) {
                chip.disabled = true;
                chip.setAttribute('aria-disabled', 'true');
                chip.classList.add('disabled');
                chip.title = 'The github tag is managed automatically via GitHub integration.';
            } else {
                chip.addEventListener('click', handleInlineTagToggle);
            }
            inlineTagOptions.appendChild(chip);
        });
    }

    function handleInlineTagToggle(event) {
        event.preventDefault();
        const tagId = event.currentTarget.dataset.tagId;
        if (!tagId) {
            return;
        }
        const tag = availableTagsMap.get(tagId);
        if (!tag) {
            return;
        }
        if ((tag.name || '').toLowerCase() === GITHUB_LOCAL_TAG_NAME) {
            if (typeof displayFlashMessage === 'function') {
                const message = editingTaskHasGithub
                    ? 'The github tag is managed automatically for linked GitHub issues.'
                    : 'The github tag can only be added by linking this task to a GitHub issue.';
                displayFlashMessage(message, 'info');
            }
            return;
        }
        if (inlineSelectedTags.has(tagId)) {
            inlineSelectedTags.delete(tagId);
        } else {
            inlineSelectedTags.set(tagId, tag);
        }
        autoAppliedTagIds.delete(tagId);
        syncInlineTagsField();
        renderInlineTagOptions();
        if (inlineTagFeedback) {
            inlineTagFeedback.classList.add('d-none');
        }
    }

    function clearInlineSelection() {
        inlineSelectedTags = new Map();
        clearAutoAppliedTags();
        syncInlineTagsField();
        renderInlineTagOptions();
        if (inlineTagInput) {
            inlineTagInput.value = '';
        }
        if (inlineTagFeedback) {
            inlineTagFeedback.classList.add('d-none');
        }
    }

    function handleTaskFormSubmit(event) {
        if (!taskForm) {
            return;
        }
        if (event) {
            event.preventDefault();
            if (event.submitter && event.submitter.type === 'reset') {
                return;
            }
        }
        if (taskForm.dataset.ajaxSubmitting === 'true') {
            return;
        }

        applyTaskFormErrors({});
        if (typeof syncInlineTagsField === 'function') syncInlineTagsField();
        const formData = new FormData(taskForm);
        if (formData.has('name')) {
            formData.set('name', (formData.get('name') || '').trim());
        }

        taskForm.dataset.ajaxSubmitting = 'true';
        if (quickAddBtn) {
            quickAddBtn.disabled = true;
        }

        const actionUrl = getTaskFormAction();

        fetch(actionUrl, {
            method: 'POST',
            body: formData,
            headers: {
                'X-Requested-With': 'XMLHttpRequest',
                Accept: 'application/json',
            },
        })
            .then((response) =>
                response
                    .json()
                    .catch(() => ({}))
                    .then((data) => ({ ok: response.ok, data }))
            )
            .then(({ ok, data }) => {
                if (!ok || !data || data.success !== true) {
                    const errors = (data && data.errors) || {};
                    applyTaskFormErrors(errors);
                    const message = (data && data.message) || 'Unable to save task.';
                    displayFlashMessage(message, 'danger');
                    const error = new Error(message);
                    error.silent = true;
                    throw error;
                }

                applyTaskFormErrors({});
                const message = data.message || (isEditingCurrentTask() ? 'Task updated!' : 'Task added!');
                displayFlashMessage(message, 'success');

                if (!isEditingCurrentTask()) {
                    persistLastUsedTagsForScope(Array.from(inlineSelectedTags.values()));
                }
                taskForm.reset();
                collapseAccordionItem('detailed-item-container');
                if (nameFieldAutoResize) {
                    nameFieldAutoResize.refresh();
                }
                if (descriptionFieldAutoResize) {
                    descriptionFieldAutoResize.refresh();
                }
                setTaskFormActionToAdd();

                return refreshTaskList().then(() => {
                    if (nameField) {
                        nameField.focus({ preventScroll: false });
                        nameField.select();
                    }
                });
            })
            .catch((error) => {
                if (!error || !error.silent) {
                    console.error('Task form submission failed', error);
                }
            })
            .finally(() => {
                if (quickAddBtn) {
                    quickAddBtn.disabled = false;
                }
                taskForm.dataset.ajaxSubmitting = 'false';
            });
    }

    function focusTaskFormForGroup({ tagIdValue = null, dueBucket = null } = {}) {
        if (!taskForm || !nameField) {
            return;
        }

        const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
        taskForm.scrollIntoView({ behavior: prefersReducedMotion ? 'auto' : 'smooth', block: 'start' });
        window.setTimeout(() => {
            nameField.focus();
            nameField.select();
        }, prefersReducedMotion ? 0 : 150);

        let shouldExpandDetails = false;

        if (typeof tagIdValue === 'string') {
            setInlineTagsFromString(tagIdValue);
            if (tagIdValue.trim()) {
                shouldExpandDetails = true;
            }
        }

        if (typeof dueBucket === 'string' && dueBucket) {
            const applied = selectDueDateBucket(dueBucket);
            if (applied && dueBucket !== 'without_due') {
                shouldExpandDetails = true;
            }
        }

        if (shouldExpandDetails && detailedItemCollapse) {
            detailedItemCollapse.show();
        }
    }

    function attachGroupAddListeners() {
        document.querySelectorAll('.task-group-add-btn').forEach((button) => {
            if (button.dataset.quickAddBound === 'true') {
                return;
            }
            button.dataset.quickAddBound = 'true';
            button.addEventListener('click', (event) => {
                event.preventDefault();
                const trigger = event.currentTarget;
                focusTaskFormForGroup({
                    tagIdValue: typeof trigger.dataset.groupTagId === 'string' ? trigger.dataset.groupTagId : null,
                    dueBucket: typeof trigger.dataset.groupDueBucket === 'string' ? trigger.dataset.groupDueBucket : null,
                });
            });
        });
    }

    const taskCopyListenerAttached = new WeakSet();
    function attachTaskCopyListeners() {
        document.querySelectorAll('.task-copy-btn').forEach((button) => {
            if (taskCopyListenerAttached.has(button)) {
                return;
            }
            taskCopyListenerAttached.add(button);
            button.addEventListener('click', (event) => {
                event.preventDefault();
                const trigger = event.currentTarget;
                const taskElement = trigger.closest('.task-item');
                const taskData = buildTaskClipboardDataFromElement(taskElement);
                const taskName = taskData && taskData.name ? taskData.name : 'Task';
                if (!taskData) {
                    displayFlashMessage('Unable to copy this task.', 'danger');
                    return;
                }
                const clipboardText = formatTaskClipboardText(taskData);
                copyTextToClipboard(clipboardText)
                    .then(() => {
                        displayFlashMessage(`Task "${taskName}" copied to clipboard.`, 'success');
                    })
                    .catch((error) => {
                        console.error('Unable to copy task', error);
                        displayFlashMessage('Unable to copy this task to the clipboard.', 'danger');
                    });
            });
        });
    }

    const groupCopyListenerAttached = new WeakSet();
    function attachGroupCopyListeners() {
        document.querySelectorAll('.task-group-copy-btn').forEach((button) => {
            if (groupCopyListenerAttached.has(button)) {
                return;
            }
            groupCopyListenerAttached.add(button);
            button.addEventListener('click', (event) => {
                event.preventDefault();
                const groupElement = button.closest('.task-group');
                if (!groupElement) {
                    displayFlashMessage('Unable to locate this task group.', 'danger');
                    return;
                }
                const taskElements = Array.from(groupElement.querySelectorAll('.task-item'));
                if (taskElements.length === 0) {
                    displayFlashMessage('There are no tasks to copy in this group.', 'info');
                    return;
                }
                const clipboardSections = taskElements
                    .map((taskElement) => buildTaskClipboardDataFromElement(taskElement))
                    .filter(Boolean)
                    .map((taskData, index) => {
                        const formatted = formatTaskClipboardText(taskData);
                        return formatted ? `${index + 1}. ${formatted}` : null;
                    })
                    .filter(Boolean);

                if (clipboardSections.length === 0) {
                    displayFlashMessage('Unable to copy the selected tasks.', 'danger');
                    return;
                }

                const titleElement = groupElement.querySelector('.task-group-title');
                const groupTitle = titleElement ? titleElement.textContent.trim() : '';
                const header = groupTitle ? `${groupTitle}\n` : '';
                const clipboardText = `${header}${clipboardSections.join('\n\n')}`;
                copyTextToClipboard(clipboardText)
                    .then(() => {
                        const count = clipboardSections.length;
                        const label = groupTitle || 'group';
                        displayFlashMessage(
                            `Copied ${count} task${count === 1 ? '' : 's'} from "${label}" to the clipboard.`,
                            'success'
                        );
                    })
                    .catch((error) => {
                        console.error('Unable to copy tasks from group', error);
                        displayFlashMessage('Unable to copy tasks from this group.', 'danger');
                    });
            });
        });
    }

    function updateFilterToggleState(isExpanded) {
        filterToggleButtons.forEach((button) => {
            button.setAttribute('aria-expanded', isExpanded ? 'true' : 'false');
        });
    }

    function applyResponsiveFilterState() {
        if (!filterCollapse) {
            return;
        }
        if (filterMediaQuery.matches) {
            filterCollapse.show();
        } else {
            filterCollapse.hide();
        }
    }

    function createTagOnServer(rawValue) {
        const normalized = (rawValue || '').replace(/^#+/, '').trim();
        if (!normalized) {
            return Promise.reject({ error: 'Please enter a tag name.' });
        }
        if (!csrfToken) {
            return Promise.reject({ error: 'Missing CSRF token.' });
        }
        return fetch('/tags', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrfToken,
            },
            body: JSON.stringify({ name: normalized }),
        })
            .then((response) => {
                if (!response.ok) {
                    return response.json().then((data) => Promise.reject(data));
                }
                return response.json();
            })
            .then((data) => {
                if (!data || !data.tag) {
                    return Promise.reject({ error: 'Unable to create tag.' });
                }
                return data.tag;
            });
    }

    function handleInlineTagCreate() {
        if (!inlineTagInput) {
            return;
        }
        createTagOnServer(inlineTagInput.value)
            .then((tag) => {
                ensureTagInFilter(tag);
                inlineSelectedTags.set(String(tag.id), {
                    id: Number(tag.id),
                    name: tag.name,
                });
                autoAppliedTagIds.delete(String(tag.id));
                syncInlineTagsField();
                renderInlineTagOptions();
                inlineTagInput.value = '';
                if (inlineTagFeedback) {
                    inlineTagFeedback.classList.add('d-none');
                }
            })
            .catch((error) => {
                if (inlineTagFeedback) {
                    const message = error && error.error ? error.error : 'Unable to create tag.';
                    inlineTagFeedback.textContent = message;
                    inlineTagFeedback.classList.remove('d-none');
                }
            });
    }

    function updateDateDisplays() {
        document.querySelectorAll('.due-date').forEach((element) => {
            const formatted = formatDateTimeDisplay(element.dataset.utcDate);
            if (formatted) {
                element.textContent = `Due: ${formatted}`;
            }
        });
        document.querySelectorAll('.completed-date').forEach((element) => {
            const formatted = formatDateTimeDisplay(element.dataset.completedDate);
            if (formatted) {
                element.textContent = `Completed: ${formatted}`;
            }
        });
    }

    const csrfTokenInput = taskForm ? taskForm.querySelector('input[name="csrf_token"]') : null;
    const csrfToken = csrfTokenInput ? csrfTokenInput.value : null;

    const tagModalElement = document.getElementById('tagManagerModal');
    const tagModal = tagModalElement ? new bootstrap.Modal(tagModalElement) : null;
    const tagModalAvailable = document.getElementById('tag-modal-available');
    const tagModalEmpty = document.getElementById('tag-modal-empty');
    const tagModalTaskName = document.getElementById('tag-modal-task-name');
    const newTagInput = document.getElementById('new-tag-input');
    const newTagFeedback = document.getElementById('new-tag-feedback');
    const createTagBtn = document.getElementById('create-tag-btn');

    let availableTagsMap = new Map();
    let currentTaskId = null;
    let currentTaskTags = new Map();
    let inlineSelectedTags = new Map();
    let autoAppliedTagIds = new Set();
    let currentTaskHasGithub = false;
    let editingTaskHasGithub = false;
    const pendingTagDeletions = new Map();
    const collapseSkipGithubSync = new WeakSet();
    let lastFilterSignature = null;

    function fetchGitHubIssueSync(taskId) {
        if (!taskId) {
            return Promise.resolve({ ok: false, status: 400, data: null });
        }
        const token = csrfTokenInput ? csrfTokenInput.value : null;
        return fetch('/api/github/issue/sync', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-Requested-With': 'XMLHttpRequest',
                ...(token ? { 'X-CSRFToken': token } : {}),
            },
            body: JSON.stringify({ task_id: taskId }),
        })
            .then((response) =>
                response
                    .json()
                    .catch(() => ({}))
                    .then((data) => ({ ok: response.ok, status: response.status, data }))
            )
            .catch((error) => {
                console.error('GitHub sync request failed', error);
                return { ok: false, status: 0, data: null, error };
            });
    }

    document.addEventListener('show.bs.collapse', (event) => {
        const collapseElement = event.target;
        if (!collapseElement || !collapseElement.classList || !collapseElement.classList.contains('accordion-collapse')) {
            return;
        }
        if (collapseSkipGithubSync.has(collapseElement)) {
            collapseSkipGithubSync.delete(collapseElement);
            return;
        }
        const taskElement = collapseElement.closest('.task-item');
        if (!taskElement || taskElement.dataset.taskHasGithub !== 'true') {
            return;
        }
        const taskId = Number(taskElement.dataset.taskId || '0');
        if (!taskId) {
            return;
        }

        event.preventDefault();
        const collapseId = collapseElement.id;

        (async () => {
            try {
                const { ok, status, data } = await fetchGitHubIssueSync(taskId);
                if (!ok || !data || !data.success) {
                    const message = (data && data.message) || 'Unable to sync GitHub issue.';
                    if (typeof displayFlashMessage === 'function' && message) {
                        displayFlashMessage(message, 'danger');
                    }
                    if ((status === 404 || status === 410) && typeof refreshTaskList === 'function') {
                        try {
                            await refreshTaskList();
                        } catch (error) {
                            console.error('Unable to refresh tasks after missing GitHub issue', error);
                        }
                    }
                    if (collapseElement && collapseElement.isConnected) {
                        collapseSkipGithubSync.add(collapseElement);
                        bootstrap.Collapse.getOrCreateInstance(collapseElement, { toggle: false }).show();
                    }
                    return;
                }

                if (
                    data.github_issue_unlinked &&
                    typeof displayFlashMessage === 'function'
                ) {
                    const message = data.message || GITHUB_ISSUE_MISSING_MESSAGE;
                    displayFlashMessage(message, 'warning');
                }

                let targetCollapse = collapseElement;
                if (typeof refreshTaskList === 'function') {
                    try {
                        await refreshTaskList();
                        let nextCollapse = collapseId ? document.getElementById(collapseId) : null;
                        if (!nextCollapse) {
                            const nextTaskElement = document.querySelector(`.task-item[data-task-id="${taskId}"]`);
                            nextCollapse = nextTaskElement ? nextTaskElement.querySelector('.accordion-collapse') : null;
                        }
                        if (nextCollapse) {
                            targetCollapse = nextCollapse;
                        }
                    } catch (error) {
                        console.error('Unable to refresh tasks after GitHub detail sync', error);
                    }
                }

                if (!targetCollapse || !targetCollapse.isConnected) {
                    if (typeof displayFlashMessage === 'function') {
                        displayFlashMessage('GitHub issue synced. The task list has been refreshed.', 'info');
                    }
                    return;
                }
                collapseSkipGithubSync.add(targetCollapse);
                bootstrap.Collapse.getOrCreateInstance(targetCollapse, { toggle: false }).show();
            } catch (error) {
                console.error('Unable to sync GitHub issue before expanding', error);
                if (typeof displayFlashMessage === 'function') {
                    displayFlashMessage('Unable to fetch the latest GitHub issue data.', 'danger');
                }
                if (collapseElement && collapseElement.isConnected) {
                    collapseSkipGithubSync.add(collapseElement);
                    bootstrap.Collapse.getOrCreateInstance(collapseElement, { toggle: false }).show();
                }
            }
        })();
    });

    function updateFilterEmptyState() {
        if (!filterContainer || !filterEmptyMessage) {
            return;
        }
        const hasTags = filterContainer.querySelectorAll('.tag-filter-button').length > 0;
        filterEmptyMessage.classList.toggle('d-none', hasTags);
    }

    function hydrateAvailableTagsFromFilter() {
        if (!filterContainer) {
            return;
        }
        availableTagsMap = new Map();
        filterContainer.querySelectorAll('.tag-filter-button').forEach((button) => {
            const tagId = String(button.dataset.tagId);
            availableTagsMap.set(tagId, {
                id: Number(tagId),
                name: button.dataset.tagName || button.textContent.replace('#', '').trim(),
                task_count: Number(button.dataset.tagCount || '0'),
            });
        });
        updateFilterEmptyState();
    }

    function createFilterButton(tag) {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'btn btn-sm tag-chip tag-filter-button';
        button.dataset.tagId = String(tag.id);
        button.dataset.tagName = tag.name;
        button.dataset.tagCount = String(tag.task_count || 0);

        const label = document.createElement('span');
        label.className = 'tag-filter-label';
        label.textContent = `#${tag.name}`;

        const remove = document.createElement('span');
        remove.className = 'tag-filter-remove';
        remove.setAttribute('role', 'button');
        remove.setAttribute('tabindex', '0');
        remove.setAttribute('aria-label', `Delete tag #${tag.name}`);
        remove.dataset.tagId = String(tag.id);

        const icon = document.createElement('i');
        icon.className = 'bi bi-x-lg';
        remove.appendChild(icon);

        button.append(label, remove);
        if ((tag.name || '').toLowerCase() === GITHUB_LOCAL_TAG_NAME) {
            remove.classList.add('d-none');
            remove.setAttribute('aria-hidden', 'true');
        }
        return button;
    }

    function normalizeTagPayload(tag) {
        if (!tag || tag.id === undefined || tag.id === null) {
            return null;
        }
        const id = Number(tag.id);
        if (Number.isNaN(id)) {
            return null;
        }
        const name = typeof tag.name === 'string' ? tag.name : '';
        const rawCount = tag.task_count ?? tag.taskCount ?? tag.count ?? 0;
        const count = Number(rawCount);
        return {
            id,
            name,
            task_count: Number.isNaN(count) ? 0 : count,
        };
    }

    function ensureTagInFilter(tag) {
        if (!filterContainer) {
            return;
        }
        const normalized = normalizeTagPayload(tag);
        if (!normalized) {
            return;
        }
        const tagId = String(normalized.id);
        const existing = availableTagsMap.get(tagId);
        if (existing) {
            existing.name = normalized.name;
            existing.task_count = normalized.task_count;
            const button = filterContainer.querySelector(`.tag-filter-button[data-tag-id="${tagId}"]`);
            if (button) {
                button.dataset.tagName = normalized.name;
                button.dataset.tagCount = String(existing.task_count);
                const label = button.querySelector('.tag-filter-label');
                if (label) {
                    label.textContent = `#${normalized.name}`;
                }
                const remove = button.querySelector('.tag-filter-remove');
                if (remove) {
                    remove.dataset.tagId = tagId;
                    remove.setAttribute('aria-label', `Delete tag #${normalized.name}`);
                }
            }
            return;
        }
        availableTagsMap.set(tagId, { ...normalized });
        const button = createFilterButton(normalized);
        filterContainer.appendChild(button);
        updateFilterEmptyState();
    }

    function removeTagLocally(tagId, { tagName = '', applyFilters = true, refresh = false, showMessage = false } = {}) {
        const key = String(tagId);
        if (filterContainer) {
            const button = filterContainer.querySelector(`.tag-filter-button[data-tag-id="${key}"]`);
            if (button) {
                button.remove();
            }
        }
        availableTagsMap.delete(key);
        inlineSelectedTags.delete(key);
        currentTaskTags.delete(key);
        syncInlineTagsField();
        renderInlineTagOptions();
        renderTagOptions();
        updateFilterEmptyState();
        if (applyFilters) {
            applyTagFilters();
        }
        if (refresh) {
            refreshTaskList();
        }
        if (showMessage && typeof displayFlashMessage === 'function' && tagName) {
            displayFlashMessage(`Tag "#${tagName}" deleted.`, 'success');
        }
        persistTaskPreferences();
        handleActiveFilterChange();
    }

    function deleteTagFromServer(tagId, tagName = '', { onSuccess = null, onError = null, showError = true } = {}) {
        if (!tagId || !csrfToken) {
            return Promise.resolve(false);
        }
        const key = String(tagId);
        if (pendingTagDeletions.has(key)) {
            return pendingTagDeletions.get(key);
        }
        const request = fetch(`/tags/${tagId}`, {
            method: 'DELETE',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrfToken,
            },
        })
            .then((response) => {
                if (!response.ok) {
                    throw response;
                }
                return response.json();
            })
            .then((data) => {
                if (typeof onSuccess === 'function') {
                    onSuccess(data);
                }
                return true;
            })
            .catch((error) => {
                console.error('Unable to delete tag', error);
                if (showError && typeof displayFlashMessage === 'function') {
                    const label = tagName ? `tag "#${tagName}"` : 'tag';
                    displayFlashMessage(`Unable to delete ${label}.`, 'danger');
                }
                if (typeof onError === 'function') {
                    onError(error);
                }
                return false;
            })
            .finally(() => {
                pendingTagDeletions.delete(key);
            });
        pendingTagDeletions.set(key, request);
        return request;
    }

    function syncFilterTags(tags = []) {
        if (!filterContainer) {
            return;
        }
        const seen = new Set();
        tags.forEach((tag) => {
            const normalized = normalizeTagPayload(tag);
            if (!normalized) {
                return;
            }
            ensureTagInFilter(normalized);
            seen.add(String(normalized.id));
        });
        let removedAny = false;
        let removedActive = false;
        const existingButtons = Array.from(filterContainer.querySelectorAll('.tag-filter-button'));
        existingButtons.forEach((button) => {
            const tagId = button.dataset.tagId;
            if (seen.has(tagId)) {
                return;
            }
            removedAny = true;
            if (button.classList.contains('active')) {
                removedActive = true;
            }
            removeTagLocally(tagId, {
                tagName: button.dataset.tagName || '',
                applyFilters: false,
                refresh: false,
                showMessage: false,
            });
        });
        if (removedAny) {
            if (removedActive) {
                applyTagFilters();
            }
            updateFilterEmptyState();
        }
    }

    function getFilterTagCount(tagId) {
        const key = String(tagId);
        const tag = availableTagsMap.get(key);
        if (tag && typeof tag.task_count === 'number' && !Number.isNaN(tag.task_count)) {
            return tag.task_count;
        }
        if (!filterContainer) {
            return 0;
        }
        const button = filterContainer.querySelector(`.tag-filter-button[data-tag-id="${key}"]`);
        if (!button) {
            return 0;
        }
        const value = Number(button.dataset.tagCount || '0');
        return Number.isNaN(value) ? 0 : value;
    }

    function setFilterTagCount(tagId, value) {
        if (!filterContainer) {
            throw new Error('setFilterTagCount: filterContainer is null');
        }
        const key = String(tagId);
        const normalized = Math.max(0, Number(value) || 0);
        const button = filterContainer.querySelector(`.tag-filter-button[data-tag-id="${key}"]`);
        if (button) {
            button.dataset.tagCount = String(normalized);
        }
        const tag = availableTagsMap.get(key);
        if (tag) {
            tag.task_count = normalized;
        }
        return normalized;
    }

    function adjustFilterTagCount(tagId, delta) {
        const current = getFilterTagCount(tagId);
        const next = current + Number(delta || 0);
        return setFilterTagCount(tagId, next);
    }

    function updateTaskTagDisplay(taskId, tags) {
        const container = document.getElementById(`task-tags-${taskId}`);
        if (container) {
            container.innerHTML = '';
            tags.forEach((tag) => {
                const pill = document.createElement('span');
                pill.className = 'tag-pill';
                pill.dataset.tagId = tag.id;
                pill.dataset.tagName = tag.name;
                pill.textContent = `#${tag.name}`;
                container.appendChild(pill);
            });
        }

        const taskWrapper = document.querySelector(`.task-item[data-task-id="${taskId}"]`);
        if (taskWrapper) {
            const tagIds = tags.map((tag) => tag.id);
            taskWrapper.dataset.tagIds = tagIds.join(',');
        }
    }

    function renderTagOptions() {
        if (!tagModalAvailable) {
            return;
        }

        hydrateAvailableTagsFromFilter();
        currentTaskTags.forEach((tag) => ensureTagInFilter(tag));

        tagModalAvailable.innerHTML = '';
        const tags = Array.from(availableTagsMap.values()).sort((a, b) => a.name.localeCompare(b.name));

        if (tags.length === 0) {
            if (tagModalEmpty) {
                tagModalEmpty.classList.remove('d-none');
            }
            return;
        }

        if (tagModalEmpty) {
            tagModalEmpty.classList.add('d-none');
        }

        tags.forEach((tag) => {
            const isGithubTag = (tag.name || '').toLowerCase() === GITHUB_LOCAL_TAG_NAME;
            if (isGithubTag && !currentTaskHasGithub) {
                return;
            }
            const chip = document.createElement('button');
            chip.type = 'button';
            chip.className = 'btn btn-sm tag-chip';
            chip.dataset.tagId = tag.id;
            chip.textContent = `#${tag.name}`;
            if (currentTaskTags.has(String(tag.id))) {
                chip.classList.add('active', 'assigned');
            }
            if (isGithubTag) {
                chip.disabled = true;
                chip.setAttribute('aria-disabled', 'true');
                chip.classList.add('disabled');
                chip.title = 'The github tag is managed automatically for linked GitHub issues.';
            } else {
                chip.addEventListener('click', () => toggleTagAssignment(tag));
            }
            tagModalAvailable.appendChild(chip);
        });
    }

    function toggleTagAssignment(tag) {
        const tagId = String(tag.id);
        if (currentTaskTags.has(tagId)) {
            updateTagAssignment(tagId, false);
        } else {
            updateTagAssignment(tagId, true);
        }
    }

    function updateTagAssignment(tagId, assign) {
        if (!currentTaskId || !csrfToken) {
            return;
        }

        const url = assign ? `/tasks/${currentTaskId}/tags` : `/tasks/${currentTaskId}/tags/${tagId}`;
        const options = {
            method: assign ? 'POST' : 'DELETE',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrfToken,
            },
        };

        if (assign) {
            options.body = JSON.stringify({ tag_id: Number(tagId) });
        }

        const tagKey = String(tagId);
        const tagInfo = currentTaskTags.get(tagKey) || availableTagsMap.get(tagKey);
        const tagNameLower = tagInfo && tagInfo.name ? tagInfo.name.toLowerCase() : '';
        const isGithubTag = tagNameLower === GITHUB_LOCAL_TAG_NAME;
        const isLinkedTask = currentTaskHasGithub || editingTaskHasGithub;

        if (!assign && isGithubTag && isLinkedTask) {
            if (typeof displayFlashMessage === 'function') {
                displayFlashMessage('The github tag is managed automatically for linked GitHub issues.', 'info');
            }
            return;
        }

        if (assign && isGithubTag && !isLinkedTask) {
            if (typeof displayFlashMessage === 'function') {
                displayFlashMessage('The github tag can only be added by linking this task to a GitHub issue.', 'info');
            }
            return;
        }

        fetch(url, options)
            .then((response) =>
                response
                    .json()
                    .catch(() => ({}))
                    .then((data) => ({ ok: response.ok, data }))
            )
            .then(({ ok, data }) => {
                if (!ok) {
                    const message = data && (data.error || data.message) ? data.error || data.message : 'Unable to update tag.';
                    if (typeof displayFlashMessage === 'function') {
                        displayFlashMessage(message, 'danger');
                    }
                    return;
                }
                if (data && data.tag) {
                    const tag = data.tag;
                    const key = String(tag.id);
                    if (assign) {
                        currentTaskTags.set(key, tag);
                        ensureTagInFilter(tag);
                        adjustFilterTagCount(key, 1);
                    } else {
                        currentTaskTags.delete(key);
                        adjustFilterTagCount(key, -1);
                    }
                    updateTaskTagDisplay(currentTaskId, Array.from(currentTaskTags.values()));
                    renderTagOptions();
                    renderInlineTagOptions();
                    const shouldRefreshSort = getCurrentSortBy() === 'tags';
                    if (shouldRefreshSort) {
                        refreshTaskList();
                    } else {
                        applyTagFilters();
                    }
                }
            })
            .catch((error) => {
                console.error('Unable to update tag assignment', error);
                if (typeof displayFlashMessage === 'function') {
                    displayFlashMessage('Unable to update tag assignment.', 'danger');
                }
            });
    }

    function handleCreateTag() {
        if (!newTagInput || !currentTaskId) {
            return;
        }

        createTagOnServer(newTagInput.value)
            .then((tag) => {
                ensureTagInFilter(tag);
                newTagInput.value = '';
                if (newTagFeedback) {
                    newTagFeedback.classList.add('d-none');
                }
                const tagKey = String(tag.id);
                currentTaskTags.set(tagKey, tag);
                renderTagOptions();
                updateTagAssignment(tagKey, true);
            })
            .catch((error) => {
                if (newTagFeedback) {
                    const message = error && error.error ? error.error : 'Unable to create tag.';
                    newTagFeedback.textContent = message;
                    newTagFeedback.classList.remove('d-none');
                }
            });
    }

    function applyTagFilters() {
        const activeTags = filterContainer
            ? Array.from(filterContainer.querySelectorAll('.tag-filter-button.active')).map((button) => button.dataset.tagId)
            : [];

        const groupsContainer = getTaskGroupsContainer();
        const currentSort = groupsContainer ? groupsContainer.dataset.sortBy : null;

        const hasActiveTags = activeTags.length > 0;

        // Filter individual tasks
        document.querySelectorAll('.task-item').forEach((taskElement) => {
            const taskTags = (taskElement.dataset.tagIds || '').split(',').filter(Boolean);
            const matches = hasActiveTags ? activeTags.every((tagId) => taskTags.includes(tagId)) : true;
            taskElement.style.display = matches ? '' : 'none';
        });

        // Filter groups
        document.querySelectorAll('.task-group').forEach((group) => {
            if (!hasActiveTags) {
                // No active filters - show all groups
                group.style.display = '';
                return;
            }

            if (currentSort === 'tags') {
                // When sorting by tags, only show groups for selected tags
                const groupTagId = group.dataset.tagId;
                if (groupTagId && activeTags.includes(groupTagId)) {
                    // This is a tag group for one of the selected tags
                    group.style.display = '';
                } else if (!groupTagId && activeTags.length > 0) {
                    // This is the "Untagged" group - hide it when filtering by tags
                    group.style.display = 'none';
                } else {
                    // This is a tag group for a non-selected tag
                    group.style.display = 'none';
                }
            } else {
                // For other sorting methods, show groups that have visible tasks
                const hasVisibleTask = Array.from(group.querySelectorAll('.task-item')).some((task) => task.style.display !== 'none');
                group.style.display = hasVisibleTask ? '' : 'none';
            }
        });
    }

    const handleFilterContainerClick = (event) => {
        const removeTarget = event.target.closest('.tag-filter-remove');
        if (removeTarget) {
            event.preventDefault();
            const tagId = removeTarget.dataset.tagId;
            handleTagDelete(tagId, removeTarget);
            return;
        }
        const button = event.target.closest('.tag-filter-button');
        if (!button) {
            return;
        }
        event.preventDefault();
        handleFilterToggle(button);
    };

    function handleFilterToggle(button) {
        if (!button) {
            return;
        }
        button.classList.toggle('active');
        applyTagFilters();
        persistTaskPreferences();
        handleActiveFilterChange();
    }

    const handleFilterRemoveKeydown = (event) => {
        if (event.key !== 'Enter' && event.key !== ' ') {
            return;
        }
        const removeTarget = event.target.closest('.tag-filter-remove');
        if (!removeTarget) {
            return;
        }
        event.preventDefault();
        handleTagDelete(removeTarget.dataset.tagId, removeTarget);
    };

    if (filterContainer) {
        filterContainer.addEventListener('click', handleFilterContainerClick);
        filterContainer.addEventListener('keydown', handleFilterRemoveKeydown);
    }

    if (filterClear) {
        filterClear.addEventListener('click', (event) => {
            event.preventDefault();
            filterContainer.querySelectorAll('.tag-filter-button').forEach((button) => {
                button.classList.remove('active');
            });
            applyTagFilters();
            persistTaskPreferences();
            handleActiveFilterChange();
        });
    }

    function handleTagDelete(tagId, triggerElement) {
        if (!tagId || !csrfToken) {
            return;
        }
        const tagKey = String(tagId);
        const tagInfo = availableTagsMap.get(tagKey);
        const tagNameNormalized = tagInfo && tagInfo.name ? tagInfo.name.toLowerCase() : '';
        if (tagNameNormalized === GITHUB_LOCAL_TAG_NAME) {
            if (typeof displayFlashMessage === 'function') {
                displayFlashMessage('The github tag is managed automatically and cannot be deleted.', 'info');
            }
            return;
        }
        const button = triggerElement
            ? triggerElement.closest('.tag-filter-button')
            : filterContainer
            ? filterContainer.querySelector(`.tag-filter-button[data-tag-id="${tagId}"]`)
            : null;
        if (!button) {
            return;
        }
        const tagName = button.dataset.tagName || '';
        const currentCount = setFilterTagCount(tagKey, getFilterTagCount(tagKey));
        const shouldConfirm = currentCount > 0 && typeof showConfirmationModal === 'function';
        const proceed = shouldConfirm
            ? showConfirmationModal({
                  title: 'Delete tag',
                  message: `Delete tag "#${tagName}"?`,
                  description: `Deleting this tag will remove "#${tagName}" from every associated task.`,
                  details: [
                      `Tag: #${tagName}`,
                      `${currentCount} task${currentCount === 1 ? '' : 's'} currently use this tag.`,
                      'This action cannot be undone.',
                  ],
                  confirmLabel: 'Delete tag',
                  confirmVariant: 'danger',
              })
            : Promise.resolve(true);

        Promise.resolve(proceed).then((confirmed) => {
            if (!confirmed) {
                return;
            }
            deleteTagFromServer(tagId, tagName, {
                onSuccess: () => {
                    removeTagLocally(tagKey, {
                        tagName,
                        applyFilters: true,
                        refresh: true,
                        showMessage: true,
                    });
                },
            });
        });
    }

    function parseTaskTagString(tagString) {
        if (!tagString) {
            return [];
        }
        return tagString
            .split(',')
            .map((value) => value.trim())
            .filter((value) => value.length > 0);
    }

    const defaultMilestoneWarningMessage = githubMilestoneWarning
        ? githubMilestoneWarning.textContent.trim()
        : '';

    function getTaskDataFromButton(button) {
        if (!button) {
            return {};
        }
        const taskId = Number(button.getAttribute('data-task-id')) || null;
        const tagString = button.getAttribute('data-task-tags') || '';
        return {
            id: taskId,
            name: button.getAttribute('data-task-name') || '',
            description: button.getAttribute('data-task-description') || '',
            end_date: button.getAttribute('data-task-end_date') || '',
            tag_ids: parseTaskTagString(tagString),
            has_github_issue: button.getAttribute('data-task-has-github') === 'true',
            github_issue_state: button.getAttribute('data-task-github-state') || '',
            github_repo_owner: button.getAttribute('data-task-github-owner') || '',
            github_repo_name: button.getAttribute('data-task-github-name') || '',
            github_milestone_number:
                button.getAttribute('data-task-github-milestone-number') || '',
            github_milestone_title:
                button.getAttribute('data-task-github-milestone-title') || '',
        };
    }

    function hideMilestoneWarning() {
        if (!githubMilestoneWarning) {
            return;
        }
        githubMilestoneWarning.classList.add('d-none');
        if (defaultMilestoneWarningMessage) {
            githubMilestoneWarning.textContent = defaultMilestoneWarningMessage;
        }
    }

    function showMilestoneWarning(message) {
        if (!githubMilestoneWarning) {
            return;
        }
        githubMilestoneWarning.textContent = message || defaultMilestoneWarningMessage || '';
        githubMilestoneWarning.classList.remove('d-none');
    }

    function resetMilestoneSelect() {
        if (!githubMilestoneSelect) {
            return;
        }
        githubMilestoneSelect.innerHTML = '';
        const placeholder = document.createElement('option');
        placeholder.value = '';
        placeholder.textContent = 'Select a milestone';
        githubMilestoneSelect.appendChild(placeholder);
        githubMilestoneSelect.value = '';
    }

    function hideMilestoneField() {
        if (githubMilestoneContainer) {
            githubMilestoneContainer.classList.add('d-none');
        }
        hideMilestoneWarning();
        resetMilestoneSelect();
        if (githubMilestoneSelect) {
            githubMilestoneSelect.disabled = true;
        }
    }

    function showMilestoneField() {
        if (githubMilestoneContainer) {
            githubMilestoneContainer.classList.remove('d-none');
        }
    }

    function setMilestoneSelectLoading(isLoading) {
        if (!githubMilestoneSelect) {
            return;
        }
        if (isLoading) {
            githubMilestoneSelect.disabled = true;
            githubMilestoneSelect.innerHTML = '';
            const option = document.createElement('option');
            option.value = '';
            option.textContent = 'Loading milestones...';
            githubMilestoneSelect.appendChild(option);
        }
    }

    function applyMilestoneOptions(milestones, currentNumber, currentTitle) {
        if (!githubMilestoneSelect) {
            return;
        }
        githubMilestoneSelect.innerHTML = '';
        const placeholder = document.createElement('option');
        placeholder.value = '';
        placeholder.textContent = 'Select a milestone';
        githubMilestoneSelect.appendChild(placeholder);

        const targetNumber = currentNumber ? String(currentNumber) : '';
        let hasSelected = false;

        milestones.forEach((milestone) => {
            if (!milestone || typeof milestone !== 'object') {
                return;
            }
            const { number, title, state } = milestone;
            if (typeof number !== 'number') {
                return;
            }
            const option = document.createElement('option');
            option.value = JSON.stringify(milestone);
            const stateLabel = state && String(state).toLowerCase() === 'closed' ? ' (closed)' : '';
            option.textContent = `${title || `Milestone #${number}`}${stateLabel}`;
            if (String(number) === targetNumber) {
                option.selected = true;
                hasSelected = true;
            }
            githubMilestoneSelect.appendChild(option);
        });

        if (!hasSelected && targetNumber) {
            const fallback = document.createElement('option');
            const parsedNumber = Number(targetNumber);
            fallback.value = JSON.stringify({
                number: parsedNumber,
                title: currentTitle || `Milestone #${targetNumber}`,
                state: 'open',
            });
            fallback.textContent = currentTitle || `Milestone #${targetNumber}`;
            fallback.selected = true;
            githubMilestoneSelect.appendChild(fallback);
        }

        githubMilestoneSelect.disabled = false;
    }

    function fetchMilestonesForRepo(owner, name) {
        const normalizedOwner = (owner || '').trim();
        const normalizedName = (name || '').trim();
        if (!normalizedOwner || !normalizedName) {
            return Promise.reject(new Error('Repository selection is required.'));
        }
        const cacheKey = `${normalizedOwner}/${normalizedName}`.toLowerCase();
        const cached = milestoneCache.get(cacheKey);
        if (cached) {
            return Promise.resolve({ cacheKey, milestones: cached });
        }
        return fetch('/api/github/milestones', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-Requested-With': 'XMLHttpRequest',
                ...(csrfToken ? { 'X-CSRFToken': csrfToken } : {}),
            },
            body: JSON.stringify({ repository: { owner: normalizedOwner, name: normalizedName } }),
        })
            .then((response) =>
                response
                    .json()
                    .catch(() => ({}))
                    .then((data) => ({ ok: response.ok, data }))
            )
            .then(({ ok, data }) => {
                if (!ok || !data || data.success !== true || !Array.isArray(data.milestones)) {
                    const message = (data && data.message) || 'Unable to load GitHub milestones.';
                    const error = new Error(message);
                    if (data && data.permission_error) {
                        error.permission = true;
                    }
                    throw error;
                }
                milestoneCache.set(cacheKey, data.milestones);
                return { cacheKey, milestones: data.milestones };
            });
    }

    function populateMilestoneSelectForRepo(owner, name, currentNumber, currentTitle) {
        if (!githubMilestoneSelect) {
            return;
        }
        const normalizedOwner = (owner || '').trim();
        const normalizedName = (name || '').trim();
        if (!normalizedOwner || !normalizedName) {
            hideMilestoneField();
            return;
        }

        showMilestoneField();
        hideMilestoneWarning();
        const cacheKey = `${normalizedOwner}/${normalizedName}`.toLowerCase();
        activeMilestoneRequestKey = cacheKey;

        const cached = milestoneCache.get(cacheKey);
        if (cached) {
            applyMilestoneOptions(cached, currentNumber, currentTitle);
            return;
        }

        setMilestoneSelectLoading(true);
        fetchMilestonesForRepo(normalizedOwner, normalizedName)
            .then(({ cacheKey: resolvedKey, milestones }) => {
                if (activeMilestoneRequestKey !== resolvedKey) {
                    return;
                }
                applyMilestoneOptions(milestones, currentNumber, currentTitle);
            })
            .catch((error) => {
                if (activeMilestoneRequestKey !== cacheKey) {
                    return;
                }
                const message = (error && error.message) || 'Unable to load GitHub milestones.';
                if (error && error.permission) {
                    showMilestoneWarning(message);
                } else if (typeof displayFlashMessage === 'function') {
                    displayFlashMessage(message, 'danger');
                }
                resetMilestoneSelect();
                if (currentNumber) {
                    applyMilestoneOptions([], currentNumber, currentTitle);
                }
                githubMilestoneSelect.disabled = true;
            })
            .finally(() => {
                if (activeMilestoneRequestKey === cacheKey && githubMilestoneSelect.options.length <= 1) {
                    githubMilestoneSelect.disabled = true;
                }
            });
    }

    function setMilestoneModalLoading(isLoading) {
        if (!milestoneModalElement) {
            return;
        }
        if (milestoneModalLoading) {
            milestoneModalLoading.classList.toggle('d-none', !isLoading);
        }
        if (milestoneModalOptions) {
            if (isLoading) {
                milestoneModalOptions.classList.add('d-none');
                milestoneModalOptions.innerHTML = '';
            }
        }
        if (milestoneModalEmpty) {
            milestoneModalEmpty.classList.add('d-none');
        }
        if (milestoneModalError) {
            milestoneModalError.classList.add('d-none');
        }
    }

    function hideMilestoneModalError() {
        if (milestoneModalError) {
            milestoneModalError.classList.add('d-none');
            milestoneModalError.textContent = '';
        }
    }

    function showMilestoneModalError(message) {
        if (!milestoneModalError) {
            return;
        }
        milestoneModalError.textContent = message || 'Unable to load milestones for this repository.';
        milestoneModalError.classList.remove('d-none');
    }

    function updateMilestoneConfirmState() {
        if (!milestoneModalConfirm) {
            return;
        }
        if (!activeMilestoneTask) {
            milestoneModalConfirm.disabled = true;
            return;
        }
        const initialNumber =
            activeMilestoneTask.initialNumber === null || activeMilestoneTask.initialNumber === undefined
                ? null
                : Number(activeMilestoneTask.initialNumber);
        const selectedNumber = selectedMilestoneOption ? Number(selectedMilestoneOption.number) : null;
        const initialDue = activeMilestoneTask.initialDue || '';
        const selectedDue = selectedMilestoneOption ? selectedMilestoneOption.due_on || '' : '';
        const changed = initialNumber !== selectedNumber || (selectedNumber !== null && selectedDue !== initialDue);
        milestoneModalConfirm.disabled = !changed;
    }

    function formatMilestoneTooltipText(title, dueOn) {
        const parts = [];
        const trimmedTitle = (title || '').trim();
        if (trimmedTitle) {
            parts.push(trimmedTitle);
        }
        if (dueOn) {
            const formattedDue = typeof formatDateTimeDisplay === 'function' ? formatDateTimeDisplay(dueOn) : dueOn;
            if (formattedDue) {
                parts.push(`Due ${formattedDue}`);
            }
        }
        if (parts.length === 0) {
            return 'GitHub milestone';
        }
        return parts.join('  ');
    }

    function applyMilestoneTooltip(element) {
        if (!element) {
            return;
        }
        const title = element.getAttribute('data-current-milestone-title') || '';
        const dueOn = element.getAttribute('data-current-milestone-due') || '';
        const tooltipText = formatMilestoneTooltipText(title, dueOn);
        element.setAttribute('title', tooltipText);
        element.setAttribute('data-bs-original-title', tooltipText);
        const existing = milestoneTooltipInstances.get(element);
        if (existing) {
            existing.dispose();
            milestoneTooltipInstances.delete(element);
        }
        if (typeof bootstrap !== 'undefined' && bootstrap.Tooltip) {
            const instance = new bootstrap.Tooltip(element, { trigger: 'hover focus' });
            milestoneTooltipInstances.set(element, instance);
        }
    }

    function renderMilestoneModalOptions(milestones, currentNumber) {
        if (!milestoneModalOptions) {
            return;
        }
        milestoneModalOptions.innerHTML = '';
        const currentNumberString = currentNumber === null || currentNumber === undefined ? '' : String(currentNumber);

        const createOptionButton = (label, data) => {
            const button = document.createElement('button');
            button.type = 'button';
            button.className = 'list-group-item list-group-item-action';
            button.textContent = label;
            button.dataset.milestoneOption = data ? String(data.number) : '';
            button.addEventListener('click', () => {
                milestoneModalOptions.querySelectorAll('.list-group-item').forEach((item) => {
                    item.classList.remove('active');
                });
                button.classList.add('active');
                selectedMilestoneOption = data ? { ...data } : null;
                updateMilestoneConfirmState();
            });
            milestoneModalOptions.appendChild(button);
            return button;
        };

        const noneButton = createOptionButton('No milestone', null);
        if (!currentNumberString) {
            noneButton.classList.add('active');
            selectedMilestoneOption = null;
        }

        if (Array.isArray(milestones) && milestones.length > 0) {
            milestones.forEach((milestone) => {
                if (!milestone || typeof milestone !== 'object') {
                    return;
                }
                const { number, title, state, due_on: dueOn } = milestone;
                if (typeof number !== 'number') {
                    return;
                }
                const label = title || `Milestone #${number}`;
                const button = createOptionButton(label, {
                    number,
                    title: label,
                    state: state || null,
                    due_on: dueOn || null,
                });
                if (String(number) === currentNumberString) {
                    button.classList.add('active');
                    selectedMilestoneOption = {
                        number,
                        title: label,
                        state: state || null,
                        due_on: dueOn || null,
                    };
                }
            });
            if (milestoneModalEmpty) {
                milestoneModalEmpty.classList.add('d-none');
            }
        } else if (milestoneModalEmpty) {
            milestoneModalEmpty.classList.remove('d-none');
        }

        if (currentNumberString) {
            const hasSelection = milestoneModalOptions.querySelector('.list-group-item.active');
            if (!hasSelection && selectedMilestoneOption) {
                const fallbackLabel = selectedMilestoneOption.title || `Milestone #${currentNumberString}`;
                const fallbackButton = createOptionButton(fallbackLabel, {
                    number: Number(currentNumberString),
                    title: fallbackLabel,
                    state: selectedMilestoneOption.state || null,
                    due_on: selectedMilestoneOption.due_on || null,
                });
                fallbackButton.classList.add('active');
            }
        }

        milestoneModalOptions.classList.remove('d-none');
        updateMilestoneConfirmState();
    }

    function openMilestoneModalForTrigger(trigger) {
        if (!trigger || !milestoneModalInstance) {
            return;
        }
        const taskId = Number(trigger.getAttribute('data-task-id')) || null;
        if (!taskId) {
            return;
        }
        const owner = trigger.getAttribute('data-github-owner') || TASK_SCOPE_GITHUB.owner || '';
        const name = trigger.getAttribute('data-github-name') || TASK_SCOPE_GITHUB.name || '';
        if (!owner || !name) {
            if (typeof displayFlashMessage === 'function') {
                displayFlashMessage('Unable to determine the GitHub repository for this task.', 'danger');
            }
            return;
        }
        const taskName = trigger.getAttribute('data-task-name') || '';
        const currentNumberRaw = trigger.getAttribute('data-current-milestone-number') || '';
        const currentTitle = trigger.getAttribute('data-current-milestone-title') || '';
        const currentDue = trigger.getAttribute('data-current-milestone-due') || '';
        const currentNumber = currentNumberRaw ? Number(currentNumberRaw) : null;

        activeMilestoneTask = {
            id: taskId,
            name: taskName,
            owner,
            repo: name,
            initialNumber: currentNumber,
            initialDue: currentDue,
        };
        selectedMilestoneOption = currentNumber !== null
            ? {
                  number: currentNumber,
                  title: currentTitle || `Milestone #${currentNumber}`,
                  due_on: currentDue || null,
              }
            : null;

        if (milestoneModalTaskName) {
            milestoneModalTaskName.textContent = taskName ? `Task: ${taskName}` : '';
        }
        hideMilestoneModalError();
        setMilestoneModalLoading(true);
        if (milestoneModalConfirm) {
            milestoneModalConfirm.disabled = true;
        }

        milestoneModalInstance.show();

        fetchMilestonesForRepo(owner, name)
            .then(({ milestones }) => {
                setMilestoneModalLoading(false);
                renderMilestoneModalOptions(milestones, currentNumber);
            })
            .catch((error) => {
                const message = (error && error.message) || 'Unable to load GitHub milestones.';
                setMilestoneModalLoading(false);
                showMilestoneModalError(message);
            });
    }

    const milestoneTriggerListenerAttached = new WeakSet();

    function attachMilestoneTriggerListeners(context = document) {
        if (!context) {
            return;
        }
        context.querySelectorAll('[data-task-milestone-trigger]').forEach((element) => {
            if (milestoneTriggerListenerAttached.has(element)) {
                return;
            }
            milestoneTriggerListenerAttached.add(element);
            element.addEventListener('click', (event) => {
                event.preventDefault();
                openMilestoneModalForTrigger(element);
            });
        });
    }

    function initializeMilestoneTooltips(context = document) {
        if (typeof bootstrap === 'undefined' || !bootstrap.Tooltip || !context) {
            return;
        }
        context
            .querySelectorAll('[data-task-milestone-trigger][data-bs-toggle="tooltip"]')
            .forEach((element) => {
                if (element.classList.contains('github-milestone-pill')) {
                    applyMilestoneTooltip(element);
                } else {
                    const existing = milestoneTooltipInstances.get(element);
                    if (existing) {
                        existing.dispose();
                        milestoneTooltipInstances.delete(element);
                    }
                    const instance = new bootstrap.Tooltip(element, { trigger: 'hover focus' });
                    milestoneTooltipInstances.set(element, instance);
                }
            });
    }

    function resetMilestoneModal() {
        hideMilestoneModalError();
        if (milestoneModalOptions) {
            milestoneModalOptions.innerHTML = '';
            milestoneModalOptions.classList.add('d-none');
        }
        if (milestoneModalEmpty) {
            milestoneModalEmpty.classList.add('d-none');
        }
        if (milestoneModalLoading) {
            milestoneModalLoading.classList.add('d-none');
        }
        if (milestoneModalConfirm) {
            milestoneModalConfirm.disabled = true;
            if (milestoneModalConfirm.dataset.originalLabel) {
                milestoneModalConfirm.innerHTML = milestoneModalConfirm.dataset.originalLabel;
                delete milestoneModalConfirm.dataset.originalLabel;
            }
        }
        if (milestoneModalTaskName) {
            milestoneModalTaskName.textContent = '';
        }
        activeMilestoneTask = null;
        selectedMilestoneOption = null;
    }

    function submitMilestoneSelection() {
        if (!milestoneModalConfirm || !activeMilestoneTask) {
            return;
        }
        const taskId = Number(activeMilestoneTask.id) || null;
        if (!taskId) {
            return;
        }
        const payload = {
            milestone: selectedMilestoneOption
                ? {
                      number: selectedMilestoneOption.number,
                      title: selectedMilestoneOption.title || '',
                      state: selectedMilestoneOption.state || null,
                      due_on: selectedMilestoneOption.due_on || null,
                  }
                : null,
        };

        const originalLabel = milestoneModalConfirm.innerHTML;
        milestoneModalConfirm.dataset.originalLabel = originalLabel;
        milestoneModalConfirm.innerHTML =
            '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>';
        milestoneModalConfirm.disabled = true;

        fetch(`/api/tasks/${taskId}/milestone`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-Requested-With': 'XMLHttpRequest',
                Accept: 'application/json',
                ...(csrfToken ? { 'X-CSRFToken': csrfToken } : {}),
            },
            body: JSON.stringify(payload),
        })
            .then((response) =>
                response
                    .json()
                    .catch(() => ({}))
                    .then((data) => ({ ok: response.ok, status: response.status, data }))
            )
            .then(({ ok, data }) => {
                if (!ok || !data || data.success !== true) {
                    const message = (data && data.message) || 'Unable to update the milestone.';
                    if (data && data.github_issue_unlinked) {
                        milestoneModalConfirm.innerHTML = originalLabel;
                        milestoneModalConfirm.disabled = true;
                        milestoneModalInstance.hide();
                        if (typeof displayFlashMessage === 'function') {
                            displayFlashMessage(message, 'warning');
                        }
                        if (typeof refreshTaskList === 'function') {
                            refreshTaskList().catch((error) => {
                                console.error('Unable to refresh tasks after milestone update', error);
                            });
                        }
                        return;
                    }
                    showMilestoneModalError(message);
                    milestoneModalConfirm.innerHTML = originalLabel;
                    milestoneModalConfirm.disabled = false;
                    return;
                }
                if (typeof displayFlashMessage === 'function' && data.message) {
                    displayFlashMessage(data.message, 'success');
                }
                milestoneModalInstance.hide();
                if (typeof refreshTaskList === 'function') {
                    refreshTaskList().catch((error) => {
                        console.error('Unable to refresh tasks after milestone update', error);
                    });
                }
            })
            .catch((error) => {
                console.error('Unable to update milestone.', error);
                showMilestoneModalError('Unable to update the milestone.');
                milestoneModalConfirm.innerHTML = originalLabel;
                milestoneModalConfirm.disabled = false;
            });
    }

    function prepareGitHubMilestoneField(taskData) {
        if (!githubMilestoneSelect || !githubMilestoneContainer) {
            return;
        }
        if (!taskData || !taskData.has_github_issue) {
            hideMilestoneField();
            return;
        }
        const owner = taskData.github_repo_owner || TASK_SCOPE_GITHUB.owner;
        const name = taskData.github_repo_name || TASK_SCOPE_GITHUB.name;
        const currentNumber = taskData.github_milestone_number || '';
        const currentTitle = taskData.github_milestone_title || '';
        populateMilestoneSelectForRepo(owner, name, currentNumber, currentTitle);
    }


    function applyTaskDataToButton(button, taskData) {
        if (!button || !taskData) {
            return;
        }
        if (Object.prototype.hasOwnProperty.call(taskData, 'name')) {
            button.setAttribute('data-task-name', taskData.name || '');
        }
        if (Object.prototype.hasOwnProperty.call(taskData, 'description')) {
            button.setAttribute('data-task-description', taskData.description || '');
        }
        if (Object.prototype.hasOwnProperty.call(taskData, 'end_date')) {
            const endDate = taskData.end_date || '';
            if (endDate) {
                button.setAttribute('data-task-end_date', endDate);
            } else {
                button.removeAttribute('data-task-end_date');
            }
        }
        if (Object.prototype.hasOwnProperty.call(taskData, 'tag_ids')) {
            const tags = Array.isArray(taskData.tag_ids)
                ? taskData.tag_ids
                      .map((value) => String(value).trim())
                      .filter((value) => value.length > 0)
                : parseTaskTagString(taskData.tag_ids);
            button.setAttribute('data-task-tags', tags.join(','));
        }
        if (Object.prototype.hasOwnProperty.call(taskData, 'has_github_issue')) {
            button.dataset.taskHasGithub = taskData.has_github_issue ? 'true' : 'false';
        }
        if (Object.prototype.hasOwnProperty.call(taskData, 'github_issue_state')) {
            button.dataset.taskGithubState = taskData.github_issue_state || '';
        }
        if (Object.prototype.hasOwnProperty.call(taskData, 'github_repo_owner')) {
            button.dataset.taskGithubOwner = taskData.github_repo_owner || '';
        }
        if (Object.prototype.hasOwnProperty.call(taskData, 'github_repo_name')) {
            button.dataset.taskGithubName = taskData.github_repo_name || '';
        }
        if (Object.prototype.hasOwnProperty.call(taskData, 'github_milestone_number')) {
            const milestoneNumber =
                taskData.github_milestone_number === null || taskData.github_milestone_number === undefined
                    ? ''
                    : String(taskData.github_milestone_number);
            if (milestoneNumber) {
                button.dataset.taskGithubMilestoneNumber = milestoneNumber;
            } else {
                button.removeAttribute('data-task-github-milestone-number');
            }
        }
        if (Object.prototype.hasOwnProperty.call(taskData, 'github_milestone_title')) {
            const milestoneTitle = taskData.github_milestone_title || '';
            if (milestoneTitle) {
                button.dataset.taskGithubMilestoneTitle = milestoneTitle;
            } else {
                button.removeAttribute('data-task-github-milestone-title');
            }
        }
        if (Object.prototype.hasOwnProperty.call(taskData, 'github_milestone_due_on')) {
            const milestoneDue = taskData.github_milestone_due_on || '';
            if (milestoneDue) {
                button.dataset.taskGithubMilestoneDue = milestoneDue;
            } else {
                button.removeAttribute('data-task-github-milestone-due');
            }
        }
    }

    function openTaskEditForm(button) {
        if (!button) {
            return;
        }
        const taskData = getTaskDataFromButton(button);
        if (nameField) {
            nameField.value = taskData.name || '';
            if (nameFieldAutoResize) {
                nameFieldAutoResize.refresh();
            }
        }

        editingTaskHasGithub = taskData.has_github_issue;
        prepareGitHubMilestoneField(taskData);

        if (descriptionField) {
            descriptionField.value = taskData.description || '';
            if (descriptionFieldAutoResize) {
                descriptionFieldAutoResize.refresh();
            }
        }

        if (endDateField) {
            const rawDate = taskData.end_date;
            endDateField.value = rawDate ? convertToLocal(rawDate) : '';
        }

        const tagString = button.getAttribute('data-task-tags') || '';
        if (tagsField) {
            tagsField.value = tagString;
        }
        setInlineTagsFromString(tagString, button.getAttribute('data-task-id'));

        const baseUrl = '{{ url_for("edit_task", id=0) }}';
        const actionUrl = baseUrl.replace('/0', `/${button.getAttribute('data-task-id')}`);
        if (taskForm) {
            taskForm.action = actionUrl;
        }

        applyTaskFormErrors({});
        expandAccordionItem('detailed-item-container');
        window.scrollTo({ top: 0, behavior: 'smooth' });
    }

    // Use WeakSet to track attached listeners for edit-task-btn
    const editTaskListenerAttached = new WeakSet();
    function attachEditTaskListeners() {
        document.querySelectorAll('.edit-task-btn').forEach((button) => {
            if (editTaskListenerAttached.has(button)) {
                return;
            }
            editTaskListenerAttached.add(button);
            button.addEventListener('click', (event) => {
                event.preventDefault();
                const fallbackData = getTaskDataFromButton(button);
                const showForm = (taskData) => {
                    applyTaskDataToButton(button, taskData);
                    openTaskEditForm(button);
                };

                if (fallbackData.has_github_issue && fallbackData.id) {
                    const originalContent = button.innerHTML;
                    button.disabled = true;
                    button.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>';

                    fetchGitHubIssueSync(fallbackData.id)
                        .then(({ ok, status, data }) => {
                            if (ok && data && data.success && data.task) {
                                const payload = data.task;
                                const normalized = {
                                    id: payload.id ?? fallbackData.id,
                                    name:
                                        typeof payload.name === 'string'
                                            ? payload.name
                                            : fallbackData.name,
                                    description:
                                        typeof payload.description === 'string'
                                            ? payload.description
                                            : fallbackData.description,
                                    end_date: payload.end_date || '',
                                    tag_ids: Array.isArray(payload.tag_ids)
                                        ? payload.tag_ids.map((value) => String(value))
                                        : fallbackData.tag_ids,
                                    has_github_issue:
                                        typeof payload.has_github_issue === 'boolean'
                                            ? payload.has_github_issue
                                            : fallbackData.has_github_issue,
                                    github_issue_state: payload.github_issue_state || '',
                                };
                                if (
                                    data.github_issue_unlinked &&
                                    typeof displayFlashMessage === 'function'
                                ) {
                                    const message = data.message || GITHUB_ISSUE_MISSING_MESSAGE;
                                    displayFlashMessage(message, 'warning');
                                }
                                showForm(normalized);
                                if (typeof refreshTaskList === 'function') {
                                    refreshTaskList().catch((error) => {
                                        console.error('Unable to refresh tasks after pre-edit sync', error);
                                    });
                                }
                                return;
                            }
                            const message = (data && data.message) || 'Unable to sync GitHub issue.';
                            if (typeof displayFlashMessage === 'function' && message) {
                                displayFlashMessage(message, 'danger');
                            }
                            showForm(fallbackData);
                            if ((status === 404 || status === 410) && typeof refreshTaskList === 'function') {
                                refreshTaskList().catch((error) => {
                                    console.error('Unable to refresh tasks after missing GitHub issue', error);
                                });
                            }
                        })
                        .catch((error) => {
                            console.error('Unable to sync GitHub issue before editing', error);
                            if (typeof displayFlashMessage === 'function') {
                                displayFlashMessage('Unable to fetch the latest GitHub issue data.', 'danger');
                            }
                            showForm(fallbackData);
                        })
                        .finally(() => {
                            button.disabled = false;
                            button.innerHTML = originalContent;
                        });
                    return;
                }

                showForm(fallbackData);
            });
        });
    }

    const taskDeleteListenerAttached = new WeakSet();
    function attachTaskDeleteListeners() {
        document.querySelectorAll('.task-delete-btn').forEach((button) => {
            if (taskDeleteListenerAttached.has(button)) {
                return;
            }
            taskDeleteListenerAttached.add(button);
            button.addEventListener('click', (event) => {
                event.preventDefault();
                if (typeof showConfirmationModal !== 'function') {
                    const hasGithub = button.dataset.taskHasGithub === 'true';
                    const githubState = (button.dataset.taskGithubState || '').toLowerCase();
                    if (hasGithub && githubState !== 'closed' && typeof displayFlashMessage === 'function') {
                        displayFlashMessage('Task cannot be deleted until its linked GitHub issue is closed.', 'warning');
                    }
                    if (hasGithub && githubState !== 'closed') {
                        return;
                    }
                    return;
                }
                const hasGithub = button.dataset.taskHasGithub === 'true';
                const githubState = (button.dataset.taskGithubState || '').toLowerCase();
                if (hasGithub && githubState !== 'closed') {
                    showConfirmationModal({
                        title: 'Linked GitHub issue',
                        message: 'Task cannot be deleted until its linked GitHub issue is closed.',
                        description: '',
                        confirmLabel: 'Got it',
                        confirmVariant: 'primary',
                    });
                    return;
                }
                const actionUrl = button.dataset.confirmUrl;
                if (!actionUrl) {
                    return;
                }
                const taskName = button.dataset.taskName || button.getAttribute('aria-label') || 'this task';
                const detailItems = [];
                const dueDate = button.dataset.taskDueDate;
                const formattedDue = typeof formatDateTimeDisplay === 'function'
                    ? formatDateTimeDisplay(dueDate)
                    : '';
                if (formattedDue) {
                    detailItems.push(`Due ${formattedDue}`);
                }

                const tagCount = Number(button.dataset.taskTagCount || '0');
                if (tagCount > 0) {
                    let tagNames = [];
                    try {
                        tagNames = JSON.parse(button.dataset.taskTags || '[]');
                    } catch (error) {
                        tagNames = [];
                    }
                    if (Array.isArray(tagNames) && tagNames.length > 0) {
                        const formattedTags = tagNames
                            .map((name) => (typeof name === 'string' && name.trim() ? `#${name.trim()}` : null))
                            .filter(Boolean)
                            .join(', ');
                        if (formattedTags) {
                            detailItems.push(`Tags: ${formattedTags}`);
                        }
                    }
                    if (!detailItems.some((item) => item.startsWith('Tags'))) {
                        detailItems.push(`${tagCount} tag${tagCount === 1 ? '' : 's'} assigned.`);
                    }
                }

                if (button.dataset.taskCompleted === 'true') {
                    const completedDate = button.dataset.taskCompletedDate;
                    const formattedCompleted = typeof formatDateTimeDisplay === 'function'
                        ? formatDateTimeDisplay(completedDate)
                        : '';
                    detailItems.push(
                        formattedCompleted
                            ? `Completed ${formattedCompleted}`
                            : 'Task is already marked as completed.'
                    );
                }

                detailItems.unshift(`Task: ${taskName}`);
                showConfirmationModal({
                    title: 'Delete task',
                    message: `Delete task "${taskName}"?`,
                    description: `Deleting this task will permanently remove "${taskName}" and its activity.`,
                    details: [...detailItems, 'This action cannot be undone.'],
                    confirmLabel: 'Delete task',
                    confirmVariant: 'danger',
                }).then((confirmed) => {
                    if (!confirmed) {
                        return;
                    }
                    fetch(actionUrl, {
                        method: 'POST',
                        headers: {
                            'X-Requested-With': 'XMLHttpRequest',
                            Accept: 'application/json',
                        },
                    })
                        .then((response) =>
                            response
                                .json()
                                .catch(() => ({}))
                                .then((data) => ({ ok: response.ok, data }))
                        )
                        .then(({ ok, data }) => {
                            if (!ok || !data || data.success !== true) {
                                const message = (data && data.message) || `Unable to delete "${taskName}".`;
                                displayFlashMessage(message, 'danger');
                                return;
                            }
                            const message = (data && data.message) || `Task "${taskName}" deleted.`;
                            displayFlashMessage(message, 'success');
                            refreshTaskList();
                        })
                        .catch((error) => {
                            console.error('Unable to delete task', error);
                            displayFlashMessage(`Unable to delete "${taskName}".`, 'danger');
                        });
                });
            });
        });
    }

    const githubButtonListenerAttached = new WeakSet();
    function attachGitHubButtons() {
        document.querySelectorAll('.task-github-btn').forEach((button) => {
            if (githubButtonListenerAttached.has(button)) {
                return;
            }
            githubButtonListenerAttached.add(button);
            button.addEventListener('click', () => {
                const taskId = Number(button.dataset.taskId || 0);
                if (!taskId) {
                    return;
                }
                const hasIssue = button.dataset.hasIssue === 'true';
                const endpoint = hasIssue ? '/api/github/issue/sync' : '/api/github/issue/create';
                const csrfField = document.getElementById('csrf_token');
                const csrfToken = csrfField ? csrfField.value : null;
                const originalContent = button.innerHTML;
                button.disabled = true;
                button.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>';

                fetch(endpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Requested-With': 'XMLHttpRequest',
                        ...(csrfToken ? { 'X-CSRFToken': csrfToken } : {}),
                    },
                    body: JSON.stringify({ task_id: taskId }),
                })
                    .then((response) =>
                        response
                            .json()
                            .catch(() => ({}))
                            .then((data) => ({ ok: response.ok, status: response.status, data }))
                    )
                    .then(({ ok, status, data }) => {
                        if (!ok || !data || !data.success) {
                            const message = (data && data.message) || 'GitHub action failed.';
                            displayFlashMessage(message, 'danger');
                            if ((status === 404 || status === 410) && typeof refreshTaskList === 'function') {
                                refreshTaskList();
                            }
                            return;
                        }
                        if (data.github_issue_unlinked) {
                            if (typeof displayFlashMessage === 'function') {
                                const infoMessage = data.message || GITHUB_ISSUE_MISSING_MESSAGE;
                                displayFlashMessage(infoMessage, 'warning');
                            }
                            button.dataset.hasIssue = 'false';
                            button.dataset.taskHasGithub = 'false';
                            button.dataset.taskGithubState = '';
                        } else {
                            const issue = data.issue || {};
                            const issueNumber = issue.number ? `#${issue.number}` : '';
                            const message = hasIssue
                                ? `GitHub issue ${issueNumber} synced.`
                                : `GitHub issue ${issueNumber} created.`;
                            displayFlashMessage(message.trim(), 'success');
                            const milestoneInfo = issue.milestone || null;
                            if (milestoneInfo && typeof milestoneInfo === 'object') {
                                const {
                                    number: milestoneNumber,
                                    title: milestoneTitle,
                                    due_on: milestoneDueOn,
                                } = milestoneInfo;
                                if (milestoneNumber !== null && milestoneNumber !== undefined) {
                                    button.dataset.taskGithubMilestoneNumber = String(milestoneNumber);
                                    button.dataset.taskGithubMilestoneTitle = milestoneTitle || '';
                                    if (milestoneDueOn) {
                                        button.dataset.taskGithubMilestoneDue = milestoneDueOn;
                                    } else {
                                        button.removeAttribute('data-task-github-milestone-due');
                                    }
                                } else {
                                    button.removeAttribute('data-task-github-milestone-number');
                                    button.removeAttribute('data-task-github-milestone-title');
                                    button.removeAttribute('data-task-github-milestone-due');
                                }
                            }
                        }
                        if (Array.isArray(data.warnings)) {
                            data.warnings
                                .filter((warning) => typeof warning === 'string' && warning.trim())
                                .forEach((warning) => {
                                    displayFlashMessage(warning.trim(), 'warning');
                                });
                        }
                        if (data.task && typeof data.task === 'object') {
                            applyTaskDataToButton(button, {
                                github_issue_state: data.task.github_issue_state || '',
                                has_github_issue:
                                    typeof data.task.has_github_issue === 'boolean'
                                        ? data.task.has_github_issue
                                        : button.dataset.taskHasGithub === 'true',
                                github_milestone_number:
                                    data.task.github_milestone_number !== undefined
                                        ? data.task.github_milestone_number
                                        : button.getAttribute('data-task-github-milestone-number') || '',
                                github_milestone_title:
                                    data.task.github_milestone_title !== undefined
                                        ? data.task.github_milestone_title
                                        : button.getAttribute('data-task-github-milestone-title') || '',
                                github_milestone_due_on:
                                    data.task.github_milestone_due_on !== undefined
                                        ? data.task.github_milestone_due_on
                                        : button.getAttribute('data-task-github-milestone-due') || '',
                                github_repo_owner: data.task.github_repo_owner || button.dataset.taskGithubOwner || '',
                                github_repo_name: data.task.github_repo_name || button.dataset.taskGithubName || '',
                            });
                        }
                        refreshTaskList().catch((error) => {
                            console.error('Unable to refresh tasks after GitHub action', error);
                        });
                    })
                    .catch((error) => {
                        console.error('GitHub action failed', error);
                        displayFlashMessage('Unable to communicate with GitHub.', 'danger');
                    })
                    .finally(() => {
                        button.disabled = false;
                        button.innerHTML = originalContent;
                    });
            });
        });
    }

    const taskCompleteListenerAttached = new WeakSet();
    function attachTaskCompleteListeners() {
        document.querySelectorAll('.task-complete-btn').forEach((button) => {
            if (taskCompleteListenerAttached.has(button)) {
                return;
            }
            taskCompleteListenerAttached.add(button);
            button.addEventListener('click', (event) => {
                event.preventDefault();
                const url = button.getAttribute('href');
                if (!url) {
                    return;
                }
                const taskName = button.dataset.taskName || button.getAttribute('aria-label') || 'this task';
                const hasGithubIssue = button.dataset.taskHasGithub === 'true';
                const githubState = (button.dataset.taskGithubState || '').toLowerCase();

                const executeToggle = () => {
                    fetch(url, {
                        headers: {
                            'X-Requested-With': 'XMLHttpRequest',
                            Accept: 'application/json',
                        },
                    })
                        .then((response) =>
                            response
                                .json()
                                .catch(() => null)
                                .then((data) => ({ ok: response.ok, data }))
                        )
                        .then(({ ok, data }) => {
                            if (!ok || !data) {
                                throw new Error('Invalid response');
                            }
                            if (!data.success) {
                                const errorMessage = data.message || `Unable to update "${taskName}".`;
                                displayFlashMessage(errorMessage, data.category || 'danger');
                                return;
                            }

                            const message =
                                data.message
                                || (data.completed
                                    ? `Task "${taskName}" completed.`
                                    : `Task "${taskName}" restored.`);
                            const category = data.category || 'success';
                            displayFlashMessage(message, category);

                            return refreshTaskList().catch((error) => {
                                console.error('Unable to refresh tasks after completion', error);
                                displayFlashMessage('Task updated, but the list could not be refreshed.', 'warning');
                            });
                        })
                        .catch((error) => {
                            console.error('Unable to toggle task completion', error);
                            displayFlashMessage(`Unable to update "${taskName}".`, 'danger');
                        });
                };

                if (hasGithubIssue && githubState !== 'closed' && typeof showConfirmationModal === 'function') {
                    showConfirmationModal({
                        title: 'Complete task',
                        message: 'This will close the linked GitHub issue. Continue?',
                        confirmLabel: 'Close issue',
                        cancelLabel: 'Cancel',
                        confirmVariant: 'primary',
                    }).then((confirmed) => {
                        if (confirmed) {
                            executeToggle();
                        }
                    });
                    return;
                }

                executeToggle();
            });
        });
    }

    function attachTagManagerListeners() {
        document.querySelectorAll('.tag-manager-btn').forEach((button) => {
            if (button.dataset.tagManagerListenerAttached === 'true') {
                return;
            }
            button.dataset.tagManagerListenerAttached = 'true';
            button.addEventListener('click', (event) => {
                event.preventDefault();
                if (!tagModal) {
                    return;
                }

                currentTaskId = button.dataset.taskId;
                currentTaskTags = new Map();
                currentTaskHasGithub = button.dataset.taskHasGithub === 'true';

                if (tagModalTaskName) {
                    const taskLabel = button.dataset.taskName || 'this task';
                    tagModalTaskName.textContent = `Task: "${taskLabel}"`;
                }

                const tagContainer = document.getElementById(`task-tags-${currentTaskId}`);
                if (tagContainer) {
                    tagContainer.querySelectorAll('[data-tag-id]').forEach((pill) => {
                        const id = String(pill.dataset.tagId);
                        currentTaskTags.set(id, {
                            id: Number(id),
                            name: pill.dataset.tagName || pill.textContent.replace('#', '').trim(),
                        });
                    });
                }

                renderTagOptions();

                if (newTagInput) {
                    newTagInput.value = '';
                    newTagInput.focus({ preventScroll: true });
                }

                if (newTagFeedback) {
                    newTagFeedback.classList.add('d-none');
                }

                tagModal.show();
            });
        });
    }

    if (quickCancelBtn) {
        quickCancelBtn.addEventListener('click', () => {
            setTaskFormActionToAdd();
            clearInlineSelection();
            collapseAccordionItem('detailed-item-container');
            applyTaskFormErrors({});
            applyDefaultInlineTags({ reason: 'quick-cancel' });
        });
    }

    if (taskForm) {
        taskForm.addEventListener('reset', () => {
            setTaskFormActionToAdd();
            clearInlineSelection();
            applyTaskFormErrors({});
            if (nameFieldAutoResize) {
                nameFieldAutoResize.refresh();
            }
            if (descriptionFieldAutoResize) {
                descriptionFieldAutoResize.refresh();
            }
            applyDefaultInlineTags({ reason: 'form-reset' });
            editingTaskHasGithub = false;
        });
        if (typeof window.fetch === 'function') {
            taskForm.addEventListener('submit', handleTaskFormSubmit);
        }
        taskForm.addEventListener('keydown', (event) => {
            if (!(event.ctrlKey || event.metaKey)) {
                return;
            }
            if (event.key !== 'Enter') {
                return;
            }
            if (isEditingCurrentTask()) {
                return;
            }
            if (taskForm.dataset.ajaxSubmitting === 'true') {
                return;
            }
            event.preventDefault();
            if (quickAddBtn) {
                quickAddBtn.click();
                return;
            }
            if (typeof taskForm.requestSubmit === 'function') {
                taskForm.requestSubmit();
            } else {
                taskForm.submit();
            }
        });
    }

    function buildFilterUrl() {
        if (!filterForm) {
            return window.location.pathname;
        }
        const params = new URLSearchParams();
        const formData = new FormData(filterForm);
        formData.forEach((value, key) => {
            if (key === 'search') {
                const trimmed = (value || '').trim();
                if (!trimmed) {
                    return;
                }
                params.append(key, trimmed);
                return;
            }
            if (key === 'show_completed') {
                if (!filterCompleted || !filterCompleted.checked) {
                    return;
                }
            }
            if (value === null || value === undefined || value === '') {
                return;
            }
            params.append(key, value);
        });
        const queryString = params.toString();
        return `${filterForm.action}${queryString ? `?${queryString}` : ''}`;
    }

    function refreshTaskList() {
        if (!filterForm) {
            console.warn('refreshTaskList: filterForm is missing. Task list will not be updated.');
            return Promise.resolve();
        }
        const url = buildFilterUrl();
        history.replaceState(null, '', url);
        return fetch(url, {
            headers: {
                'X-Requested-With': 'XMLHttpRequest',
            },
        })
            .then((response) => {
                if (!response.ok) {
                    throw response;
                }
                return response.json();
            })
            .then((data) => {
                if (!data || typeof data.html !== 'string') {
                    return;
                }
                const template = document.createElement('template');
                template.innerHTML = data.html.trim();
                const newContainer = template.content.firstElementChild;
                const currentContainer = getTaskGroupsContainer();
                if (currentContainer) {
                    currentContainer
                        .querySelectorAll('[data-task-milestone-trigger][data-bs-toggle="tooltip"]')
                        .forEach((element) => {
                            const instance = milestoneTooltipInstances.get(element);
                            if (instance) {
                                instance.dispose();
                                milestoneTooltipInstances.delete(element);
                            }
                        });
                }
                if (newContainer && currentContainer) {
                    currentContainer.replaceWith(newContainer);
                }
                if (Array.isArray(data.available_tags)) {
                    syncFilterTags(data.available_tags);
                } else {
                    hydrateAvailableTagsFromFilter();
                }
                renderInlineTagOptions();
                initializeSortableGroups();
                attachTaskCompleteListeners();
                attachEditTaskListeners();
                attachTagManagerListeners();
                attachTaskDeleteListeners();
                attachGitHubButtons();
                attachTaskCopyListeners();
                attachGroupCopyListeners();
                attachGroupAddListeners();
                attachMilestoneTriggerListeners(newContainer);
                initializeMilestoneTooltips(newContainer);
                hideMilestoneField();
                updateDateDisplays();
                applyTagFilters();
                persistTaskPreferences();
                handleActiveFilterChange();
            })
            .catch((error) => {
                console.error('Unable to refresh tasks', error);
            });
    }

    initializeSortableGroups();
    hydrateAvailableTagsFromFilter();
    if (tagsField && tagsField.value) {
        setInlineTagsFromString(tagsField.value);
    } else {
        clearInlineSelection();
    }
    hideMilestoneField();
    attachTaskCompleteListeners();
    attachEditTaskListeners();
    attachTagManagerListeners();
    attachTaskDeleteListeners();
    attachGitHubButtons();
    attachTaskCopyListeners();
    attachGroupCopyListeners();
    attachGroupAddListeners();
    attachMilestoneTriggerListeners();
    initializeMilestoneTooltips();
    applyTagFilters();
    updateDateDisplays();

    restoreTaskPreferences();
    applyDefaultInlineTags({ reason: 'initial-load' });

    if (milestoneModalElement) {
        milestoneModalElement.addEventListener('hidden.bs.modal', resetMilestoneModal);
    }
    if (milestoneModalConfirm) {
        milestoneModalConfirm.addEventListener('click', submitMilestoneSelection);
    }

    if (filterCollapseElement && filterCollapse) {
        const handleBreakpointChange = () => {
            applyResponsiveFilterState();
        };
        filterCollapseElement.addEventListener('shown.bs.collapse', () => {
            updateFilterToggleState(true);
        });
        filterCollapseElement.addEventListener('hidden.bs.collapse', () => {
            updateFilterToggleState(false);
        });
        updateFilterToggleState(filterCollapseElement.classList.contains('show'));
        applyResponsiveFilterState();
        if (typeof filterMediaQuery.addEventListener === 'function') {
            filterMediaQuery.addEventListener('change', handleBreakpointChange);
        } else if (typeof filterMediaQuery.addListener === 'function') {
            filterMediaQuery.addListener(handleBreakpointChange);
        }
    }

    if (createTagBtn) {
        createTagBtn.addEventListener('click', handleCreateTag);
    }

    if (newTagInput) {
        newTagInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                event.preventDefault();
                handleCreateTag();
            }
        });
    }

    if (inlineTagAddBtn) {
        inlineTagAddBtn.addEventListener('click', handleInlineTagCreate);
    }

    function focusNewTask(expandDetails = true) {
        if (!taskForm) {
            return;
        }
        taskForm.reset();
        taskForm.dataset.ajaxSubmitting = 'false';
        const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
        taskForm.scrollIntoView({ behavior: prefersReducedMotion ? 'auto' : 'smooth', block: 'start' });
        if (expandDetails) {
            if (detailedItemCollapse) {
                detailedItemCollapse.show();
            } else {
                expandAccordionItem('detailed-item-container');
            }
        }
        window.setTimeout(() => {
            if (nameField) {
                nameField.focus({ preventScroll: true });
                nameField.select();
            }
        }, 0);
    }

    document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape') {
            if (!taskForm || isEditingCurrentTask()) {
                return;
            }
            if (document.body && document.body.classList.contains('modal-open')) {
                return;
            }
            const activeElement = document.activeElement;
            const activeInsideForm = activeElement ? taskForm.contains(activeElement) : false;
            const hasContent = [nameField, descriptionField, endDateField].some((field) => {
                if (!field) {
                    return false;
                }
                return (field.value || '').trim() !== '';
            });
            const detailsExpanded = detailedItemContainer && detailedItemContainer.classList.contains('show');
            if (!activeInsideForm && !hasContent && !detailsExpanded) {
                return;
            }
            event.preventDefault();
            if (quickCancelBtn) {
                quickCancelBtn.click();
            } else {
                taskForm.reset();
                collapseAccordionItem('detailed-item-container');
                applyTaskFormErrors({});
            }
            return;
        }

        const isShortcutModifier = event.ctrlKey || event.metaKey;
        if (!isShortcutModifier) {
            return;
        }
        const key = (event.key || '').toLowerCase();
        if (key === 'arrowup') {
            event.preventDefault();
            focusNewTask(true);
        }
    });

    if (nameField) {
        nameField.addEventListener('keydown', (event) => {
            if (!(event.ctrlKey || event.metaKey)) {
                return;
            }
            if (event.key !== 'ArrowDown') {
                return;
            }
            event.preventDefault();
            if (detailedItemCollapse) {
                detailedItemCollapse.show();
            } else {
                expandAccordionItem('detailed-item-container');
            }
        });
    }

    if (inlineTagInput) {
        inlineTagInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                event.preventDefault();
                handleInlineTagCreate();
            }
        });
    }

    if (filterForm) {
        filterForm.addEventListener('submit', (event) => {
            event.preventDefault();
            persistTaskPreferences();
            refreshTaskList();
        });
    }

    if (sortSelect) {
        sortSelect.addEventListener('change', () => {
            persistTaskPreferences();
            refreshTaskList();
        });
    }

    if (filterCompleted) {
        filterCompleted.addEventListener('change', () => {
            persistTaskPreferences();
            refreshTaskList();
        });
    }

    if (searchInput) {
        const debouncedSearch = debounce(() => {
            persistTaskPreferences();
            refreshTaskList();
        }, 300);
        searchInput.addEventListener('input', () => {
            debouncedSearch();
        });
    }
</script>
{% endblock  %}
