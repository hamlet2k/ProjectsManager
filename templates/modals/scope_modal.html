<div class="modal fade" id="scope-modal" tabindex="-1" aria-labelledby="scope-modal-title" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">

            <div class="modal-header">
                <h5 class="modal-title" id="scope-modal-title">Create scope</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>

            <form id="scope-form" method="post">
            {{ scope_form.hidden_tag() }}

            <div class="modal-body">
                <p class="text-muted small mb-3" id="scope-modal-description">Group related tasks by creating a new scope.</p>
                <div class="form-floating mb-3">
                    {{ scope_form.name(class_='form-control'+ (' is-invalid' if scope_form.name.errors else ''), placeholder_=scope_form.name.name) }}
                    {{ scope_form.name.label(class="form-label") }}
                    {% if scope_form.name.errors %}
                        {% for error in scope_form.name.errors %}
                            <div class="invalid-feedback" style="display:block;">{{ error }}</div>
                        {% endfor %}
                    {% endif %}
                </div>
                <div class="form-floating mb-3">
                    {{ scope_form.description(class_='form-control'+ (' is-invalid' if scope_form.description.errors else ''), placeholder_=scope_form.description.name) }}
                    {{ scope_form.description.label(class="form-label") }}
                    {% if scope_form.description.errors %}
                        {% for error in scope_form.description.errors %}
                            <div class="invalid-feedback" style="display:block;">{{ error }}</div>
                        {% endfor %}
                    {% endif %}
                </div>
                <div class="mb-3 pt-3 border-top">
                    <div class="d-flex align-items-center justify-content-between mb-2">
                        <div>
                            <h6 class="mb-1">GitHub Integration</h6>
                            <p class="text-muted small mb-0">Connect tasks in this scope to a specific repository.</p>
                        </div>
                        <div class="form-check form-switch">
                            {{ scope_form.github_enabled(class="form-check-input", id="scope-github-toggle", disabled=not github_token_present) }}
                            <label class="form-check-label" for="scope-github-toggle">Enable</label>
                        </div>
                    </div>
                    {% if not github_token_present %}
                        <div class="alert alert-info py-2 px-3 mb-2" role="alert">
                            Add a GitHub token in your user settings to enable integration.
                        </div>
                    {% endif %}
                    <div class="github-scope-settings" data-github-settings-section style="display: {{ 'block' if scope_form.github_enabled.data else 'none' }};">
                        <div class="mb-3">
                            <label class="form-label" for="scope-github-repo-select">Repository</label>
                            {{ scope_form.github_repository(class="form-select" + (' is-invalid' if scope_form.github_repository.errors else ''), id="scope-github-repo-select", **{'data-selected-repo': scope_form.github_repository.data or ''}) }}
                            {% for error in scope_form.github_repository.errors %}
                                <div class="invalid-feedback d-block">{{ error }}</div>
                            {% endfor %}
                            <div class="form-text">Choose the repository to use for GitHub actions in this scope.</div>
                        </div>
                        <div class="mb-3">
                            <label class="form-label" for="scope-github-project-select">Project (optional)</label>
                            {{ scope_form.github_project(class="form-select" + (' is-invalid' if scope_form.github_project.errors else ''), id="scope-github-project-select", **{'data-selected-project': scope_form.github_project.data or ''}) }}
                            {% for error in scope_form.github_project.errors %}
                                <div class="invalid-feedback d-block">{{ error }}</div>
                            {% endfor %}
                            <div class="form-text">Issues created for this scope will be added to the selected project column.</div>
                        </div>
                        <div class="mb-3">
                            <label class="form-label" for="scope-github-milestone-select">Milestone (optional)</label>
                            {{ scope_form.github_milestone(class="form-select" + (' is-invalid' if scope_form.github_milestone.errors else ''), id="scope-github-milestone-select", **{'data-selected-milestone': scope_form.github_milestone.data or ''}) }}
                            {% for error in scope_form.github_milestone.errors %}
                                <div class="invalid-feedback d-block">{{ error }}</div>
                            {% endfor %}
                            <div class="form-text">New issues will use this milestone by default. You can change it per task later.</div>
                        </div>
                        <div class="alert alert-warning py-2 px-3 d-none" data-github-warning role="alert">
                            A repository must be selected to enable GitHub integration for this scope.
                        </div>
                        <div class="alert alert-warning py-2 px-3 d-none" data-github-project-warning role="alert"></div>
                        <div class="alert alert-warning py-2 px-3 d-none" data-github-milestone-warning role="alert"></div>
                    </div>
                    {% for error in scope_form.github_enabled.errors %}
                        <div class="invalid-feedback d-block">{{ error }}</div>
                    {% endfor %}
                </div>
            </div>

            <div class="modal-footer">
                <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">
                Cancel
                </button>
                {{ scope_form.submit(class="btn btn-primary") }}
            </div>

            </form>
        </div>
    </div>
</div>

<script>
    const scopeForm = document.getElementById('scope-form');
    const scopeModalTitle = document.getElementById('scope-modal-title');
    const scopeModalDescription = document.getElementById('scope-modal-description');
    const scopeSubmitButton = scopeForm ? scopeForm.querySelector('[type="submit"]') : null;

    function setScopeModalContent({ title, description, submitLabel }) {
        if (scopeModalTitle) {
            scopeModalTitle.textContent = title;
        }
        if (scopeModalDescription) {
            scopeModalDescription.textContent = description;
        }
        if (scopeSubmitButton) {
            scopeSubmitButton.value = submitLabel;
            scopeSubmitButton.textContent = submitLabel;
        }
    }

    function buildCreateScopeDescription() {
        return 'Provide a name and optional description to group related tasks.';
    }

    function buildEditScopeDescription(name = '') {
        if (name && name.trim().length > 0) {
            return `Update the details for "${name.trim()}" before saving your changes.`;
        }
        return 'Update the scope details before saving your changes.';
    }

    document.addEventListener('DOMContentLoaded', () => {
        // Initialize with create scope content by default
        if (scopeForm) {
            setScopeModalContent({
                title: 'Create scope',
                description: buildCreateScopeDescription(),
                submitLabel: 'Create scope',
            });
        }

        {% if show_modal %}
            const modal = new bootstrap.Modal(document.getElementById('{{ show_modal }}'));
            modal.show();
        {% endif %}
    });

    const addScopeBtn = document.getElementById('add-scope-btn');
    if (addScopeBtn && scopeForm) {
        addScopeBtn.addEventListener('click', () => {
            scopeForm.action = '{{ url_for("add_scope") }}';
            scopeForm.reset();
            const repoSelect = document.getElementById('scope-github-repo-select');
            if (repoSelect) {
                repoSelect.innerHTML = '';
                repoSelect.dataset.selectedRepo = '';
                repoSelect.dataset.reposLoaded = 'false';
            }
            const projectSelect = document.getElementById('scope-github-project-select');
            if (projectSelect) {
                projectSelect.dataset.selectedProject = '';
                projectSelect.dataset.metadataLoaded = 'false';
            }
            const milestoneSelect = document.getElementById('scope-github-milestone-select');
            if (milestoneSelect) {
                milestoneSelect.dataset.selectedMilestone = '';
                milestoneSelect.dataset.metadataLoaded = 'false';
            }
            setScopeModalContent({
                title: 'Create scope',
                description: buildCreateScopeDescription(),
                submitLabel: 'Create scope',
            });
            const githubToggle = document.getElementById('scope-github-toggle');
            if (githubToggle) {
                githubToggle.checked = false;
                githubToggle.dispatchEvent(new Event('change'));
            }
        });
    }

    document.querySelectorAll('.edit-scope-btn').forEach((item) => {
        item.addEventListener('click', () => {
            {% for field in scope_form %}
                {% if field.type not in ['HiddenField', 'BooleanField', 'SelectField', 'SubmitField'] %}
                    const fieldElement_{{ field.name }} = document.getElementById('{{ field.name }}');
                    if (fieldElement_{{ field.name }}) {
                        fieldElement_{{ field.name }}.value = item.getAttribute('data-scope-{{ field.name }}') || '';
                    }
                {% endif %}
            {% endfor %}

            if (scopeForm) {
                const baseUrl = '{{ url_for("edit_scope", id=0) }}';
                const actionUrl = baseUrl.replace('/0', `/${item.getAttribute('data-scope-id')}`);
                scopeForm.action = actionUrl;
            }

            const githubToggle = document.getElementById('scope-github-toggle');
            const repoSelect = document.getElementById('scope-github-repo-select');
            const projectSelect = document.getElementById('scope-github-project-select');
            const milestoneSelect = document.getElementById('scope-github-milestone-select');
            if (repoSelect) {
                const repoData = item.getAttribute('data-scope-github_repository') || '';
                repoSelect.dataset.selectedRepo = repoData;
                repoSelect.dataset.reposLoaded = repoSelect.dataset.reposLoaded || 'false';
                if (!repoData) {
                    repoSelect.value = '';
                }
            }
            if (projectSelect) {
                const projectData = item.getAttribute('data-scope-github_project') || '';
                projectSelect.dataset.selectedProject = projectData;
                projectSelect.dataset.metadataLoaded = projectSelect.dataset.metadataLoaded || 'false';
            }
            if (milestoneSelect) {
                const milestoneData = item.getAttribute('data-scope-github_milestone') || '';
                milestoneSelect.dataset.selectedMilestone = milestoneData;
                milestoneSelect.dataset.metadataLoaded = milestoneSelect.dataset.metadataLoaded || 'false';
            }
            if (githubToggle) {
                const enabledValue = (item.getAttribute('data-scope-github_enabled') || '').toLowerCase();
                githubToggle.checked = enabledValue === 'true' && !githubToggle.disabled;
                githubToggle.dispatchEvent(new Event('change'));
            }
            document.dispatchEvent(new Event('scopeGithubRefresh'));

            setScopeModalContent({
                title: 'Edit scope',
                description: buildEditScopeDescription(item.getAttribute('data-scope-name') || ''),
                submitLabel: 'Save changes',
            });
        });
    });

    (function initScopeGithubSettings() {
        const toggle = document.getElementById('scope-github-toggle');
        const section = document.querySelector('[data-github-settings-section]');
        const repoWarning = document.querySelector('[data-github-warning]');
        const repoSelect = document.getElementById('scope-github-repo-select');
        const projectSelect = document.getElementById('scope-github-project-select');
        const milestoneSelect = document.getElementById('scope-github-milestone-select');
        const projectWarning = document.querySelector('[data-github-project-warning]');
        const milestoneWarning = document.querySelector('[data-github-milestone-warning]');

        if (repoSelect && !repoSelect.dataset.reposLoaded) {
            repoSelect.dataset.reposLoaded = 'false';
        }
        if (projectSelect && !projectSelect.dataset.metadataLoaded) {
            projectSelect.dataset.metadataLoaded = 'false';
        }
        if (milestoneSelect && !milestoneSelect.dataset.metadataLoaded) {
            milestoneSelect.dataset.metadataLoaded = 'false';
        }
        if (projectSelect && typeof projectSelect.dataset.selectedProject === 'undefined') {
            projectSelect.dataset.selectedProject = projectSelect.dataset.selectedProject || '';
        }
        if (milestoneSelect && typeof milestoneSelect.dataset.selectedMilestone === 'undefined') {
            milestoneSelect.dataset.selectedMilestone = milestoneSelect.dataset.selectedMilestone || '';
        }

        function hide(element) {
            if (element) {
                element.classList.add('d-none');
            }
        }

        function show(element) {
            if (element) {
                element.classList.remove('d-none');
            }
        }

        function setWarning(element, message) {
            if (!element) {
                return;
            }
            if (message) {
                element.textContent = message;
                show(element);
            } else {
                element.textContent = '';
                hide(element);
            }
        }

        function resetSelect(select, placeholder) {
            if (!select) {
                return;
            }
            select.innerHTML = '';
            const option = document.createElement('option');
            option.value = '';
            option.textContent = placeholder;
            select.appendChild(option);
            select.disabled = true;
        }

        function prepareMetadataControls() {
            resetSelect(projectSelect, 'Select a repository first');
            resetSelect(milestoneSelect, 'Select a repository first');
            setWarning(projectWarning, null);
            setWarning(milestoneWarning, null);
            if (projectSelect) {
                projectSelect.dataset.metadataLoaded = 'false';
            }
            if (milestoneSelect) {
                milestoneSelect.dataset.metadataLoaded = 'false';
            }
        }

        prepareMetadataControls();

        function markReposLoaded(isLoaded) {
            if (repoSelect) {
                repoSelect.dataset.reposLoaded = isLoaded ? 'true' : 'false';
            }
        }

        function setRepoLoading(isLoading) {
            if (!repoSelect) {
                return;
            }
            if (isLoading) {
                repoSelect.disabled = true;
                const option = document.createElement('option');
                option.value = '';
                option.textContent = 'Loading repositories...';
                repoSelect.innerHTML = '';
                repoSelect.appendChild(option);
            } else if (toggle && !toggle.disabled) {
                repoSelect.disabled = false;
            }
        }

        function applySelectedRepo() {
            if (!repoSelect) {
                return;
            }
            const selectedValue = repoSelect.dataset.selectedRepo || '';
            if (!selectedValue) {
                return;
            }
            try {
                const parsed = JSON.parse(selectedValue);
                Array.from(repoSelect.options).forEach((option) => {
                    if (!option.value) {
                        return;
                    }
                    try {
                        const value = JSON.parse(option.value);
                        if (value && value.id === parsed.id) {
                            option.selected = true;
                        }
                    } catch (error) {
                        // ignore
                    }
                });
            } catch (error) {
                // ignore invalid stored value
            }
        }

        function applySelectedProject() {
            if (!projectSelect) {
                return;
            }
            const selectedValue = projectSelect.dataset.selectedProject || '';
            if (!selectedValue) {
                return;
            }
            let parsed;
            try {
                parsed = JSON.parse(selectedValue);
            } catch (error) {
                return;
            }
            Array.from(projectSelect.options).forEach((option) => {
                if (!option.value) {
                    return;
                }
                try {
                    const value = JSON.parse(option.value);
                    if (
                        value
                        && value.id === parsed.id
                        && value.column
                        && parsed.column
                        && value.column.id === parsed.column.id
                    ) {
                        option.selected = true;
                    }
                } catch (error) {
                    // ignore
                }
            });
        }

        function applySelectedMilestone() {
            if (!milestoneSelect) {
                return;
            }
            const selectedValue = milestoneSelect.dataset.selectedMilestone || '';
            if (!selectedValue) {
                return;
            }
            let parsed;
            try {
                parsed = JSON.parse(selectedValue);
            } catch (error) {
                return;
            }
            Array.from(milestoneSelect.options).forEach((option) => {
                if (!option.value) {
                    return;
                }
                try {
                    const value = JSON.parse(option.value);
                    if (value && value.number === parsed.number) {
                        option.selected = true;
                    }
                } catch (error) {
                    // ignore
                }
            });
        }

        function getSelectedRepoPayload() {
            if (!repoSelect || !repoSelect.value) {
                return null;
            }
            try {
                return JSON.parse(repoSelect.value);
            } catch (error) {
                return null;
            }
        }

        function loadRepoMetadata({ silent = false, clearStoredSelection = false } = {}) {
            if (!toggle || toggle.disabled || !toggle.checked) {
                return;
            }
            const repoPayload = getSelectedRepoPayload();
            if (!repoPayload) {
                prepareMetadataControls();
                return;
            }
            if (clearStoredSelection) {
                if (projectSelect) {
                    projectSelect.dataset.selectedProject = '';
                }
                if (milestoneSelect) {
                    milestoneSelect.dataset.selectedMilestone = '';
                }
            }
            setWarning(projectWarning, null);
            setWarning(milestoneWarning, null);
            resetSelect(projectSelect, 'Loading projects...');
            resetSelect(milestoneSelect, 'Loading milestones...');

            fetch('/api/github/repo/metadata', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest',
                },
                body: JSON.stringify({ owner: repoPayload.owner, name: repoPayload.name }),
            })
                .then((response) =>
                    response
                        .json()
                        .catch(() => ({}))
                        .then((data) => ({ ok: response.ok, data }))
                )
                .then(({ ok, data }) => {
                    if (!projectSelect || !milestoneSelect) {
                        return;
                    }
                    projectSelect.innerHTML = '';
                    milestoneSelect.innerHTML = '';

                    const projectPlaceholder = document.createElement('option');
                    projectPlaceholder.value = '';
                    projectPlaceholder.textContent = 'Do not assign a project';
                    projectSelect.appendChild(projectPlaceholder);

                    const milestonePlaceholder = document.createElement('option');
                    milestonePlaceholder.value = '';
                    milestonePlaceholder.textContent = 'No milestone';
                    milestoneSelect.appendChild(milestonePlaceholder);

                    if (!ok || !data || !data.success) {
                        if (!silent && typeof displayFlashMessage === 'function') {
                            const message = (data && data.message) || 'Unable to load GitHub metadata.';
                            displayFlashMessage(message, 'danger');
                        }
                        projectSelect.disabled = true;
                        milestoneSelect.disabled = true;
                        return;
                    }

                    const projectItems = Array.isArray(data.projects) ? data.projects : [];
                    projectItems.forEach((project) => {
                        const columns = Array.isArray(project.columns) ? project.columns : [];
                        if (!columns.length) {
                            return;
                        }
                        const column = columns[0];
                        const optionPayload = {
                            id: project.id,
                            name: project.name,
                            column,
                        };
                        const option = document.createElement('option');
                        option.value = JSON.stringify(optionPayload);
                        option.textContent = `${project.name} â€” ${column.name}`;
                        projectSelect.appendChild(option);
                    });

                    const milestoneItems = Array.isArray(data.milestones) ? data.milestones : [];
                    milestoneItems.forEach((milestone) => {
                        const option = document.createElement('option');
                        option.value = JSON.stringify(milestone);
                        const state = milestone.state ? ` (${milestone.state})` : '';
                        option.textContent = `${milestone.title}${state}`;
                        milestoneSelect.appendChild(option);
                    });

                    projectSelect.disabled = false;
                    milestoneSelect.disabled = false;
                    projectSelect.dataset.metadataLoaded = 'true';
                    milestoneSelect.dataset.metadataLoaded = 'true';

                    applySelectedProject();
                    applySelectedMilestone();

                    setWarning(projectWarning, data.project_warning || null);
                    setWarning(milestoneWarning, data.milestone_warning || null);
                })
                .catch((error) => {
                    console.error('Unable to load GitHub metadata', error);
                    if (!silent && typeof displayFlashMessage === 'function') {
                        displayFlashMessage('Unable to load GitHub projects and milestones.', 'danger');
                    }
                    prepareMetadataControls();
                });
        }

        function loadRepositories({ silent = false } = {}) {
            if (!repoSelect || !toggle || toggle.disabled) {
                return;
            }
            setRepoLoading(true);
            fetch('/api/github/repos', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest',
                },
                body: JSON.stringify({}),
            })
                .then((response) =>
                    response
                        .json()
                        .catch(() => ({}))
                        .then((data) => ({ ok: response.ok, data }))
                )
                .then(({ ok, data }) => {
                    if (!repoSelect) {
                        return;
                    }
                    repoSelect.innerHTML = '';
                    const placeholder = document.createElement('option');
                    placeholder.value = '';
                    placeholder.textContent = 'Select a repository';
                    repoSelect.appendChild(placeholder);

                    if (!ok || !data || !data.success) {
                        if (!silent && typeof displayFlashMessage === 'function') {
                            const message = (data && data.message) || 'Unable to load GitHub repositories.';
                            displayFlashMessage(message, 'danger');
                        }
                        repoSelect.disabled = true;
                        return;
                    }

                    data.repositories.forEach((repo) => {
                        const option = document.createElement('option');
                        option.value = JSON.stringify(repo);
                        option.textContent = `${repo.owner}/${repo.name}`;
                        repoSelect.appendChild(option);
                    });
                    markReposLoaded(true);
                    applySelectedRepo();
                    repoSelect.disabled = false;
                    loadRepoMetadata({ silent: true });
                })
                .catch((error) => {
                    console.error('Unable to load repositories', error);
                    repoSelect.disabled = true;
                    markReposLoaded(false);
                    if (!silent && typeof displayFlashMessage === 'function') {
                        displayFlashMessage('Unable to load GitHub repositories.', 'danger');
                    }
                });
        }

        function updateSectionVisibility() {
            if (!section) {
                return;
            }
            const shouldShow = toggle && toggle.checked && !toggle.disabled;
            section.style.display = shouldShow ? '' : 'none';
            if (!shouldShow) {
                hide(repoWarning);
                prepareMetadataControls();
                return;
            }
            if (repoSelect && repoSelect.dataset.reposLoaded !== 'true') {
                loadRepositories({ silent: true });
                return;
            }
            loadRepoMetadata({ silent: true });
        }

        if (toggle) {
            toggle.addEventListener('change', () => {
                updateSectionVisibility();
                if (toggle.checked && repoSelect && !repoSelect.value) {
                    show(repoWarning);
                }
            });
        }

        if (scopeForm) {
            scopeForm.addEventListener('submit', () => {
                if (!toggle || !repoSelect || toggle.disabled || !toggle.checked) {
                    return;
                }
                if (!repoSelect.value) {
                    show(repoWarning);
                }
            });
        }

        if (repoSelect) {
            repoSelect.addEventListener('change', () => {
                hide(repoWarning);
                loadRepoMetadata({ clearStoredSelection: true });
            });
        }

        if (projectSelect) {
            projectSelect.addEventListener('change', () => {
                projectSelect.dataset.selectedProject = projectSelect.value || '';
                setWarning(projectWarning, null);
            });
        }

        if (milestoneSelect) {
            milestoneSelect.addEventListener('change', () => {
                if (!milestoneSelect.value) {
                    milestoneSelect.dataset.selectedMilestone = '';
                } else {
                    const selectedOption = milestoneSelect.options[milestoneSelect.selectedIndex];
                    const title = selectedOption ? selectedOption.dataset.milestoneTitle || '' : '';
                    milestoneSelect.dataset.selectedMilestone = JSON.stringify({
                        number: Number.parseInt(milestoneSelect.value, 10),
                        title,
                    });
                }
                setWarning(milestoneWarning, null);
            });
        }

        updateSectionVisibility();
        applySelectedRepo();
        applySelectedProject();
        applySelectedMilestone();

        document.addEventListener('scopeGithubRefresh', () => {
            applySelectedRepo();
            applySelectedProject();
            applySelectedMilestone();
            updateSectionVisibility();
        });
    }());
</script>

